package com.mycompany.assofjpybasic.backend.analizador.principal;

import java_cup.runtime.*;
import com.mycompany.assofjpybasic.backend.semantica.programa.*;
import java.util.ArrayList;
import java.util.List;
import com.mycompany.assofjpybasic.backend.semantica.programa.cod3.*;
import com.mycompany.assofjpybasic.backend.semantica.python.*;
import com.mycompany.assofjpybasic.backend.semantica.java.*;
import com.mycompany.assofjpybasic.backend.semantica.visual.*;
import com.mycompany.assofjpybasic.backend.error.Errores;

class SintaxisPrograma;

parser code
{:
    private Symbol s;
    private ProgramaSemantica sem = new ProgramaSemantica();
    private boolean esCase = false;
    private String java, vb, py;
    private int j, v, p, c;
    private Errores errores = new Errores();
    private int linea;

    public void setLinea(int line){
            this.linea = line;
    }
    
    public void syntax_error(Symbol sym){
            errores.errorSintactico(sym, this.c); 
    }

    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception{
            errores.errorSintactico(sym, this.c); 
    }

    public void setLineas(int j, int p, int v, int c){
            this.j = j;
            this.v = v;
            this.p = p;
            this.c = c;
    }

    public void setTipo(String java, String vb, String py){
            this.java = java;
            this.vb = vb;
            this.py = py;
            sem.iniciarJAVA(this.java, j);
    }
    
    public void reportarSem(String texto){
            errores.errorSemantico(getS(), texto, this.c);
    }

    public Symbol getS(){
        return this.cur_token;
    }
:};

terminal String voidd, mainn, constt, intt, floatt, charr, asig, andd, orr, nott;
terminal String iff, elsee, forr, switchh, casee, whilee, defaultt, breakk, doo, includee;
terminal String noigual, menor, menorig, mayor, mayorig, igig, mas, menos, por, div, mod;
terminal String para, parc, llavea, llavec, cora, corc, coma, puntocoma, dosp, punto;
terminal String printf, scanf, clrs, getch, igual, masmas, menosmenos, java, py, vb;
terminal String idlib, id, entero, decimal, character, comilla;
terminal String pyy, vbb, javaa;
terminal String string;

non terminal INCLUDE_LENG, IN_LENG, CONST;
non terminal MAIN;
non terminal Integer TYPE;
non terminal List<VariablePrograma> LIST_ASIG, ASIG_VAR;
non terminal OperacionPrograma EXPR, ASIG, OPERACION_A, OPERACION_M, OPERACION_U, ATOM, LLAMADA_METODO;
non terminal OperacionPrograma OPERACION_AC, OPERACION_MC, OPERACION_UC, ATOMC;
non terminal List<OperacionPrograma> CORCHETES, CORCHETESF, LIST_PARAM, LIST, PARAM;
non terminal String IN_CLASS;
non terminal Triplete COMPARACION;
non terminal CondicionPrograma NOT, AND, CONDICION;
non terminal ListaTripletes PRINTF, SCANF, DEF_VAR, STATEMENTLINE, STATEMENTS, STATEMENT, COMPOUND, SWITCH;
non terminal ListaTripletes OP_VAR, STEP, INICIO, IF_ELSE, ELSE, WHILE, DO_WHILE, FOR, STATEMENTSC, DEFAULT, CLASS;
non terminal List<OperacionPrograma> VARSS;
non terminal List<OperacionPrograma> VARS;
non terminal List<String> STRING;
non terminal Else_Operator ELSE_IF;
non terminal CasePrograma CASES;
non terminal List<String> PROGRAMA;
non terminal List<ObjetoPrograma> LIST_CLASS;

start with PROGRAMA;

PROGRAMA ::= INCLUDE_LENG CONST MAIN {:List<String> st = new ArrayList<>(); st.add(sem.mostrarCodigo());
                                        st.add(sem.mostrarCodigoEjecutable()); st.add(sem.crearAssembler()); RESULT = st;:}
;

INCLUDE_LENG ::= INCLUDE_LENG IN_LENG
        |
;

IN_LENG ::= py {:sem.iniciarPY(py, p);:}
        | vb {:sem.iniciarVB(vb, v);:}
        | java IN_CLASS:e1 comilla {:if(e1.equals("$$*$$")){sem.importarTodasClases();}else{sem.importarClase(e1);}:}
        | includee:e1 idlib:e2 {:sem.getImports().add(e1 + " " + e2);:}
;

IN_CLASS ::= por {:RESULT = "$$*$$";:}
        | id:e1 {:RESULT = e1;:}
;

CONST ::= CONST constt TYPE:e1 id:e2 igual OPERACION_AC:e3 puntocoma 
        {: VariablePrograma var = new ConstantePrograma(e2,ProgramaSemantica.AMBITO, e1, e3.getTipo(), null);
        var.setValor(e3.getValor());
        System.out.println("constante con id: " + e2);
        if(!sem.addVar(var)){
                reportarSem("Variable ya creda con el mismo nombre: <" + e1 + ">");
        } else {sem.getVar().addAll(e3.mostrarTripletes());
                SumOperator sum = sem.getVariables().devolverSum(e2);
                sem.getVar().add(sum);
                sem.getVar().add(new AsignarValor(null, sem.getVariables().devolverDireccion(sum),
                e3.getTriplete()));}
        :}
        | CONST ASIG_VAR:e1 {:ListaTripletes tri = new ListaTripletes();
                        for(VariablePrograma var : e1){
                        /*tri.addAll(var.mostrarTripletes());*/
                        tri.addAll(sem.getVariables().obtenerTriplete(var, var.getTipo()));
                        } sem.getVar().addAll(tri);:}
        | CONST CLASS:e1 {:sem.getVar().addAll(e1);:}
        | {::}
        | CONST constt TYPE id igual error puntocoma {:reportarSem("Error en la asignación de constante, se esperaba una operacion");:}
        | CONST constt error igual OPERACION_AC puntocoma {:reportarSem("Error en la asignacion de constante, se esperaba un id");:}
        | CONST constt TYPE id error OPERACION_AC puntocoma {:reportarSem("Error en la asignacion de constante, se esperaba un igual");:}
        | CONST constt TYPE id igual OPERACION_AC error {:reportarSem("Error en la asignacion de constante, se esperaba un ;");:}
;

TYPE ::= intt {:RESULT = VariablePrograma.INT;:}
        | floatt {:RESULT = VariablePrograma.FLOAT;:}
        | charr {:RESULT = VariablePrograma.CHAR;:}
;

/*VARGLOB ::= VARGLOB ASIG_VAR
        |
;*/

ASIG_VAR ::= TYPE:e1 LIST_ASIG:e2 puntocoma {:if(!sem.addListVar(e2, e1)){
                reportarSem("Variables con el mismo nombre");
                RESULT = new ArrayList<>();}
                else {for(VariablePrograma var : e2){
                        var.setTipo(e1);
                        if(var.getTriplete() instanceof AsignarValor)
                        ((AsignarValor)var.getTriplete()).setTipo(Triplete.tipos[e1-1]);
                } RESULT = e2;}:}
        | TYPE:e1 id:e2 CORCHETESF:e4 puntocoma {: List<VariablePrograma> var = new ArrayList<>();
                ArregloPrograma arr = new ArregloPrograma(e2, ProgramaSemantica.AMBITO, e1, e4, 
                new DefinirArreglo(null, new TerminalOperator(e2), Triplete.tipos[e1-1]));
                if(!sem.addVar(arr)){
                        reportarSem("Variable ya creda con el mismo nombre: <" + e2 + ">");
                }else {var.add(arr);} RESULT = var;:}
        | TYPE id error puntocoma {:reportarSem("Error en la asignacion de variable, se esperaba arreglo");:}
        | TYPE error CORCHETESF:e4 puntocoma {:reportarSem("Error en la asignacion de variable, se esperaba un id");:}
;

CORCHETESF ::= CORCHETESF:e1 cora OPERACION_AC:e2 corc {:if(e2.getTipo()<=VariablePrograma.INT) e1.add(e2); RESULT = e1;:}
        | cora OPERACION_AC:e1 corc {:List<OperacionPrograma> opr = new ArrayList<>();
                if(e1.getTipo()<=VariablePrograma.INT) opr.add(e1);
                RESULT = opr;:}
        | cora error corc {:reportarSem("Error en los corchetes, se esperaba una operacion"); RESULT = new ArrayList<>();:}
        | cora OPERACION_AC error {:reportarSem("Error en los corchetes, se esperaba un \"]\""); RESULT = new ArrayList<>();:}
        | error OPERACION_AC corc {:reportarSem("Error en los corchetes, se esperaba un \"]\""); RESULT = new ArrayList<>();:}
        | CORCHETESF:e1 cora error corc {:reportarSem("Error en los corchetes, se esperaba una operacion"); RESULT = e1;:}
        | CORCHETESF:e1 cora OPERACION_AC error {:reportarSem("Error en los corchetes, se esperaba un \"]\""); RESULT = e1;:}
        | CORCHETESF:e1 error OPERACION_AC corc {:reportarSem("Error en los corchetes, se esperaba un \"[\""); RESULT = e1;:}
;

CORCHETES ::= CORCHETES:e1 cora OPERACION_A:e2 corc {:if(e2.getTipo()<=VariablePrograma.INT) e1.add(e2); RESULT = e1;:}
        | cora OPERACION_A:e1 corc {:List<OperacionPrograma> opr = new ArrayList<>();
                if(e1.getTipo()<=VariablePrograma.INT) opr.add(e1);
                RESULT = opr;:}
        | cora error corc {:reportarSem("Error en los corchetes, se esperaba una operacion"); RESULT = new ArrayList<>();:}
        | cora OPERACION_A error {:reportarSem("Error en los corchetes, se esperaba un \"]\""); RESULT = new ArrayList<>();:}
        | CORCHETES:e1 cora error corc {:reportarSem("Error en los corchetes, se esperaba una operacion"); RESULT = e1;:}
;

LIST_ASIG ::= LIST_ASIG:e1 coma id:e2 ASIG:e3 {:
                if(e3!=null) e1.add(new VariablePrograma(e2, ProgramaSemantica.AMBITO, e3,
                new AsignarValor(null, new TerminalOperator(e2), e3.getTriplete())));
                else e1.add(new VariablePrograma(e2, ProgramaSemantica.AMBITO,
                new AsignarValor("", new TerminalOperator(e2), null))); RESULT = e1;:}
        | id:e1 ASIG:e2 {:List<VariablePrograma> vars = new ArrayList<>();
            if(e2!=null) vars.add(new VariablePrograma(e1, ProgramaSemantica.AMBITO, e2,
                new AsignarValor(null, new TerminalOperator(e1), e2.getTriplete()))); 
            else vars.add(new VariablePrograma(e1, ProgramaSemantica.AMBITO,
                new AsignarValor("", new TerminalOperator(e1), null))); RESULT = vars;:}
        | LIST_ASIG:e1 coma error ASIG {:reportarSem("Error en la asignacion de variables, se esperaba un id"); RESULT = new ArrayList<>();:}
        | error ASIG:e1 {:reportarSem("Error en la asignacion de variables, se esperaba un id"); RESULT = new ArrayList<>();:}
;

ASIG ::= igual EXPR:e1 {:RESULT = e1;:}
        | igual error {:reportarSem("Error en la asignacion de variable, se esperaba arreglo o puntocoma");:}
        |
;

OPERACION_A ::= OPERACION_A:e1 mas OPERACION_M:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new SumOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_A:e1 menos OPERACION_M:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new RestOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 {:RESULT = e1;:}
        | error OPERACION_M:e1 {:reportarSem("Error en una operación Aritmetica"); RESULT = e1;:}
;

OPERACION_M ::= OPERACION_M:e1 por OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new PorOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 div OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new DivOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 mod OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new ModOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_U:e1 {:RESULT = e1;:}
;

OPERACION_U ::= menos OPERACION_U:e1 {:if(e1 != null && e1.getTipo()==1){e1.setTipo(VariablePrograma.INT);}
                OperacionPrograma cero = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator("0"));
                RESULT = new OperacionPrograma(cero,
                e1, new RestOperator(null, cero.getTriplete(), e1.getTriplete(),
                Triplete.devolverTipo(cero, e1)));:}
        | mas OPERACION_U:e1 {:RESULT = e1;:}
        | ATOM:e1 {:RESULT = e1;:}
;

// Falta resolver lo de los corchetes
ATOM ::= id:e1 {:VariablePrograma var = sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)); 
                if(var == null){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else{
                        SumOperator sum = sem.getVariables().devolverSum(e1);
                        AsignarTemporal ast = new AsignarTemporal(null, sem.getVariables().devolverDireccion(sum), "float");
                        OperacionPrograma op = new OperacionPrograma(var.getTipo(), ast);
                        op.getTripletes().add(sum);
                        RESULT = op;}:}
        | entero:e1 {:RESULT = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator(e1));:}
        | decimal:e1 {:String s = ".LC" + Triplete.FLOAT;
                Triplete.FLOAT += 1;
                sem.getFl().add("\t.align 4");
                sem.getFl().add(s);
                sem.getFl().add("\t.long\t"+Float.floatToIntBits(Float.parseFloat(e1)));
                RESULT = new OperacionPrograma(VariablePrograma.FLOAT, new TerminalOperator(e1, s));:}
        | character:e1 {:RESULT = new OperacionPrograma(VariablePrograma.CHAR, new TerminalOperator(e1));:}
        | id:e1 CORCHETES:e2 {:VariablePrograma var = sem.existeVar(e1, e2.size());
                if(var == null){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else {OperacionPrograma arr = new ArregloPrograma(var.getId(), ProgramaSemantica.AMBITO,
                var.getTipo(), e2, (ArregloPrograma) var);
                SumOperator sum = sem.getVariables().devolverSum(e1);
                SumOperator sum2 = new SumOperator(null, sum, arr.getTripletes().get(arr.getTripletes().size()-1), "int");
                AsignarTemporal ast = new AsignarTemporal(null, sem.getVariables().devolverDireccion(sum2), "float");
                OperacionPrograma corch = new OperacionPrograma(var.getTipo(), ast);
                corch.getTripletes().addAll(0, arr.getTripletes());
                corch.getTripletes().add(sum);
                corch.getTripletes().add(sum2);
                RESULT = corch;}
                :}
        | para OPERACION_A:e1 parc {:RESULT = e1;:}
        | error  CORCHETES {:reportarSem("Error en la referencia de variables, se esperaba un id que haga referencia a un arreglo");:}
;

MAIN ::= voidd mainn para parc llavea STATEMENTS:e1 llavec {:sem.getTripletes().addAll(e1);:}
        | voidd error para parc llavea STATEMENTS:e1 llavec {:reportarSem("Error en el main, no tiene el main");:}
        | voidd mainn error parc llavea STATEMENTS:e1 llavec {:reportarSem("Error en el main, se espera (");:}
        | voidd mainn para error llavea STATEMENTS:e1 llavec {:reportarSem("Error en el main, se espera )");:}
        | voidd mainn para parc error STATEMENTS:e1 llavec {:reportarSem("Error en el main, se espera {");:}
;

STATEMENTS ::= STATEMENT:e1 STATEMENTS:e2 {:if(!e2.isFin()){
                                        if(e1.isRet()){
                                                reportarSem("ya existe varios returns, algunos no se toman en cuenta");
                                        } else {e1.addAll(e2);}} RESULT = e1;:}
        | {:RESULT = new ListaTripletes(true);:}
;

STATEMENT ::= COMPOUND:e1 {:RESULT = e1;:}
        | STATEMENTLINE:e1 {:RESULT = e1;:}
        | error {:reportarSem("Error en una parte del codigo"); RESULT = new ListaTripletes();:}
;

COMPOUND ::= WHILE:e1 {:RESULT = e1;:}
        | DO_WHILE:e1 {:RESULT = e1;:}
        | FOR:e1 {:RESULT = e1;:}
        | IF_ELSE:e1 {:RESULT = e1;:}
        | SWITCH:e1 {:RESULT = e1;:}
;

STATEMENTLINE ::= clrs puntocoma {:ListaTripletes tr = new ListaTripletes(); tr.add(new Clrs()); RESULT = tr;:}
        | ASIG_VAR:e1 {:ListaTripletes tri = new ListaTripletes();
                        for(VariablePrograma var : e1){
                        /*tri.addAll(var.mostrarTripletes());*/
                        tri.addAll(sem.getVariables().obtenerTriplete(var, var.getTipo()));
                        } RESULT = tri;:}
        | DEF_VAR:e1 puntocoma {:RESULT = e1;:}
        | PRINTF:e1 {:RESULT = e1;:}
        | SCANF:e1 {:RESULT = e1;:}
        | LLAMADA_METODO:e1 puntocoma {:ListaTripletes tri = new ListaTripletes();
                if(e1 != null) {tri.addAll(e1.getTripletes());
                tri.add(e1.getTriplete());}
                RESULT = tri;:}
        | getch puntocoma {:ListaTripletes tr = new ListaTripletes(); tr.add(new GetchOperator()); RESULT = tr;:}
        | CLASS:e1 {:RESULT = e1;:}
;

DEF_VAR ::= id:e1 igual EXPR:e2 {:ListaTripletes tri = new ListaTripletes();
                VariablePrograma var = sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null));
                if(var == null || var.isConstant()) {
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else if (e2 == null) {
                        reportarSem("no hay ninguna expresión en la definición de Variable");
                }else { SumOperator sum = sem.getVariables().devolverSum(e1);
                        AsignarValor asig = new AsignarValor(null, sem.getVariables().devolverDireccion(sum), e2.getTriplete());
                        /*tri.addAll(e2.mostrarTripletes());*/
                        tri.addAll(e2.mostrarTripletes());
                        tri.add(sum);
                        tri.add(asig);} RESULT = tri;:}
        | id:e1 CORCHETES:e2 igual EXPR:e3 {:VariablePrograma var = sem.existeVar(e1, e2.size());
                if(var == null){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else {OperacionPrograma arr = new ArregloPrograma(var.getId(), ProgramaSemantica.AMBITO,
                var.getTipo(), e2, (ArregloPrograma) var, e3);
                ListaTripletes tri = new ListaTripletes();
                /*if(e3.mostrarTripletes().size()>1) {
                tri.addAll(e3.mostrarTripletes().subList(1, e3.mostrarTripletes().size() - 1));}*/
                tri.addAll(arr.getTripletes());
                SumOperator sum = sem.getVariables().devolverSum(e1);
                tri.add(sum);
                SumOperator sum2 = new SumOperator(null, sum, arr.getTriplete(), "int");
                tri.add(sum2);
                if(e3.getTriplete() instanceof AsignarTemporal) tri.add(e3.getTriplete());
                AsignarValor asig = new AsignarValor(null, sem.getVariables().devolverDireccion(sum2), e3.getTriplete());
                tri.add(asig);
                RESULT = tri; }:}
        | id igual error {:reportarSem("Error en definicion de Variable, se esperaba una asignación"); RESULT = new ListaTripletes();:}
        | id error igual EXPR {:reportarSem("Error en definicion de Variable, se esperaba un ="); RESULT = new ListaTripletes();:}
        | error igual igual EXPR {:reportarSem("Error en definicion de Variable, se esperaba un id"); RESULT = new ListaTripletes();:}
        | id CORCHETES igual error {:reportarSem("Error en definicion de Arreglo, se esperaba una asignación"); RESULT = new ListaTripletes();:}
        | error CORCHETES igual error {:reportarSem("Error en definicion de Arreglo, se esperaba un id"); RESULT = new ListaTripletes();:}
;

PRINTF ::= printf para comilla STRING:e1 comilla VARS:e2 parc puntocoma 
                {:if(e1 != null) RESULT = Printf.regresarTripletes(e1, e2);:}
        | printf para error VARS parc puntocoma 
                {:reportarSem("Error en el printf, se esperaba un String"); RESULT = new ListaTripletes();:}
        | printf para comilla STRING comilla error parc puntocoma 
                {:reportarSem("Error en el printf, se esperaba una lista de variables"); RESULT = new ListaTripletes();:}
;

/*STRING ::= comilla STR comilla
;

STR ::= STR txt
        | STR MASCARA
        | txt
        | MASCARA
;

MASCARA ::= intpor
        | floatpor
        | charpor
;*/

STRING ::= STRING:e1 string:e2 {:e1.add(e2); RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

VARS ::= VARS:e1 coma EXPR:e2 {:if(e1!=null && e2!= null){e1.add(e2); RESULT = e1;}:}
        | {:List<OperacionPrograma> op = new ArrayList<>(); RESULT = op;:}
        | VARS coma error {:reportarSem("Error en una variable de un print, se esperaba una operacion"); RESULT = new ArrayList<>();:}
;

SCANF ::= scanf para comilla STRING:e1 comilla VARSS:e2 parc puntocoma 
                {:if(e2!=null) RESULT = Scanf.regresarTripletes(e1, e2);:}
        | scanf para comilla error parc puntocoma 
                {:reportarSem("Error en el scanf en los parametros, se esperaba un parametro"); RESULT = new ListaTripletes();:}
;

VARSS ::= VARSS:e2 coma asig id:e1 {:VariablePrograma var = new VariablePrograma(e1, ProgramaSemantica.AMBITO, null);
                if(sem.existeVar(var) == null
                                || e2 == null){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else {
                        SumOperator sum = sem.getVariables().devolverSum(e1);
                        OperacionPrograma op = new OperacionPrograma(var.getTipo(), sem.getVariables().devolverDireccion(sum));
                        op.getTripletes().add(sum);
                        e2.add(op); RESULT = e2;}:}
        | {:List<OperacionPrograma> arr = new ArrayList<>(); RESULT = arr;:}
        | VARSS:e2 error asig id {:reportarSem("Error en la variable del scanf, se esperaba una coma"); RESULT = e2;:}
        | VARSS:e2 coma error id {:reportarSem("Error en la variable del scanf, se esperaba un & (espacio en memoria)"); RESULT = e2;:}
        | VARSS:e2 coma asig error {:reportarSem("Error en la variable del scanf, se esperaba un id"); RESULT = e2;:}
;

IF_ELSE ::= iff para CONDICION:e1 parc llavea {:ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS:e2 llavec ELSE_IF:e3 ELSE:e4 {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                e3.agregarIf(e1, e2); RESULT = e3.juntarTripletes(e4);:}
        | iff para error parc llavea {:reportarSem("Error en un if, se esperaba una condicion"); ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS llavec ELSE_IF ELSE {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = new ListaTripletes();:}
        | error para CONDICION parc llavea {:reportarSem("Error en una condicion, se esperaba if/while"); ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS llavec ELSE_IF ELSE {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = new ListaTripletes();:}
        | iff error CONDICION parc llavea {:reportarSem("Error en un if, se esperaba ("); ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS llavec ELSE_IF ELSE {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = new ListaTripletes();:}
        | iff para CONDICION error llavea {:reportarSem("Error en un if, se esperaba )"); ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS llavec ELSE_IF ELSE {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = new ListaTripletes();:}
        | iff para CONDICION parc error {:reportarSem("Error en un if, se esperaba {"); ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS llavec ELSE_IF ELSE {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = new ListaTripletes();:}
;

ELSE_IF ::= ELSE_IF:e1 elsee iff para CONDICION:e2 parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e3 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1.agregarElseIf(e2, e3);:}
        |  ELSE_IF:e1 elsee iff para error parc llavea {:reportarSem("Error en else if, se esperaba una condicional"); ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        |  ELSE_IF:e1 elsee error para CONDICION parc llavea {:reportarSem("Error en else if, se esperaba if ya que tiene condicion"); ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        |  ELSE_IF:e1 elsee iff error CONDICION parc llavea {:reportarSem("Error en else if, se esperaba ("); ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        |  ELSE_IF:e1 elsee iff para CONDICION error llavea {:reportarSem("Error en else if, se esperaba )"); ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        |  ELSE_IF:e1 elsee iff para CONDICION parc error {:reportarSem("Error en else if, se esperaba {"); ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        | {:RESULT = new Else_Operator();:}
;

ELSE ::= elsee llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e1 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        | {:RESULT = new ListaTripletes();:}
;

SWITCH ::= switchh para EXPR:e1 parc llavea CASES:e2 DEFAULT:e3 llavec {:RESULT = e2.agregarDefault(e1, e3);:}
        | switchh para error parc llavea CASES DEFAULT llavec {:reportarSem("Error en la expresion del switch, se esperaba una Operacion"); 
                        RESULT = new ListaTripletes();:}
        | switchh error EXPR parc llavea CASES DEFAULT llavec {:reportarSem("Error en la expresion del switch, se esperaba ("); 
                        RESULT = new ListaTripletes();:}
        | switchh para EXPR error llavea CASES DEFAULT llavec {:reportarSem("Error en la expresion del switch, se esperaba )"); 
                        RESULT = new ListaTripletes();:}
        | switchh para EXPR parc error CASES DEFAULT llavec {:reportarSem("Error en la expresion del switch, se esperaba {"); 
                        RESULT = new ListaTripletes();:}
;

CASES ::= CASES:e1 casee OPERACION_A:e2 dosp {:esCase = true; ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTSC:e3 {:esCase = false; sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                if(e2!=null){RESULT  = e1.agregarCase(e2, e3);}:}
        | CASES:e1 casee error dosp {:esCase = true; ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTSC:e3 {:reportarSem("Error en la condicion del case, se espera una operacion aritmetica"); RESULT = new CasePrograma();:}
        | {:RESULT = new CasePrograma();:}
;

STATEMENTSC ::= STATEMENT:e1 STATEMENTSC:e2 {:e1.addAll(e2); RESULT = e1;:}
        | breakk puntocoma {:ListaTripletes tri = new ListaTripletes(); 
                if(!esCase){
                        reportarSem("Break fuera de un switch");
                }else{tri.add(new Break());} RESULT = tri;:}
        | {:RESULT = new ListaTripletes();:}
;

DEFAULT ::= defaultt dosp {:esCase = true; ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTSC:e1 {:esCase = false; sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        | {:RESULT = new ListaTripletes();:}
;

WHILE ::= whilee para CONDICION:e1 parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e2 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
        RESULT = Else_Operator.WHILE(e1, e2);:}
        | whilee para error parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                reportarSem("Error en la condición de un while, se esperaba una condicional"); RESULT = new ListaTripletes();:}
;

DO_WHILE ::= doo llavea {:ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS:e1 llavec whilee para CONDICION:e2 parc puntocoma {:sem.eliminarAmbito(ProgramaSemantica.AMBITO);
        ProgramaSemantica.AMBITO -= 1; RESULT = Else_Operator.DOWHILE(e2, e1);:}
;

FOR ::= forr para INICIO:e1 puntocoma CONDICION:e2 puntocoma STEP:e3 parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
        RESULT = Else_Operator.FOR(e1, e3, e2, e5);:}
        | forr para error puntocoma CONDICION puntocoma STEP parc llavea {:ProgramaSemantica.AMBITO += 1;
                                reportarSem("Error en el inicio del for, se esperaba una inicialización de variable");:}
                                STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1; RESULT = new ListaTripletes();:}
        | forr para INICIO puntocoma error puntocoma STEP parc llavea {:ProgramaSemantica.AMBITO += 1;
                                reportarSem("Error en la condicional del for, se esperaba una condicion de variable");:}
                                STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1; RESULT = new ListaTripletes();:}
        | forr para INICIO puntocoma CONDICION puntocoma error parc llavea {:ProgramaSemantica.AMBITO += 1;
                                reportarSem("Error en el Step del for, se esperaba el step del for");:}
                                STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1; RESULT = new ListaTripletes();:}
        | forr para error parc llavea {:
                                reportarSem("Error el espacio del for, se esperaba un punto y coma");:}
                                STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1; RESULT = new ListaTripletes();:}
        | forr error INICIO puntocoma CONDICION puntocoma STEP parc llavea {:
                                reportarSem("Error el espacio del for, se esperaba (");:}
                                STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1; RESULT = new ListaTripletes();:}
        | forr para INICIO puntocoma CONDICION puntocoma STEP parc error {:
                                reportarSem("Error el espacio del for, se esperaba {");:}
                                STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1; RESULT = new ListaTripletes();:}
;

INICIO ::= DEF_VAR:e1 {:RESULT = e1;:}
        | id:e1 {:if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null))== null){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                }RESULT = new ListaTripletes();:}
        | TYPE:e2 id:e1 igual EXPR:e3 {:ListaTripletes tri = new ListaTripletes();
        if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)) != null){
                reportarSem("Variable ya existente con el id: <" + e1 + ">");
        } else {
                sem.addVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO+1, null));
                tri.addAll(e3.getTripletes()); tri.add(e3.getTriplete());
                tri.add(new AsignarValor(new TerminalOperator(e1), e3.getTriplete(), Triplete.tipos[e2-1]));}:}
;

STEP ::= DEF_VAR:e1 {:RESULT = e1;:}
        | OP_VAR:e1 {:RESULT = e1;:}
;

OP_VAR ::= id:e1 masmas {:ListaTripletes tri = new ListaTripletes(); VariablePrograma vars = sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null));
                if(vars == null){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else {
                        SumOperator ss1 = sem.getVariables().devolverSum(e1);
                        tri.add(ss1);
                        AsignarTemporal ast = new AsignarTemporal(null, sem.getVariables().devolverDireccion(ss1), "float");
                        tri.add(ast);
                        SumOperator sum = new SumOperator(null, ast, new TerminalOperator("1"), OperacionJava.obtenerTipo(vars.getTipo()));
                        tri.add(sum);
                        SumOperator ss2 = sem.getVariables().devolverSum(e1);
                        tri.add(ss2);
                        tri.add(new AsignarValor(sem.getVariables().devolverDireccion(ss2), sum, null));
                } RESULT = tri;:}
        | id:e1 menosmenos {:ListaTripletes tri = new ListaTripletes(); VariablePrograma vars = new VariablePrograma(e1, ProgramaSemantica.AMBITO, null);
                if(vars == null){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else {
                        SumOperator ss1 = sem.getVariables().devolverSum(e1);
                        tri.add(ss1);
                        AsignarTemporal ast = new AsignarTemporal(null, sem.getVariables().devolverDireccion(ss1), "float");
                        tri.add(ast);
                        RestOperator rest = new RestOperator(null,ast, new TerminalOperator("1"), OperacionJava.obtenerTipo(vars.getTipo()));
                        tri.add(rest); 
                        SumOperator ss2 = sem.getVariables().devolverSum(e1);
                        tri.add(ss2);
                        tri.add(new AsignarValor(sem.getVariables().devolverDireccion(ss2), rest, null));
                } RESULT = tri;:}
        | error masmas {:reportarSem("Error en la operacion incremento, se espera un id antes del ++"); RESULT = new ListaTripletes();:}
        | error menosmenos {:reportarSem("Error en la operacion incremento, se espera un id antes del --"); RESULT = new ListaTripletes();:}
        | id error {:reportarSem("Error en la operacion incremento, se espera un ++ o --"); RESULT = new ListaTripletes();:}
;

CONDICION ::= CONDICION:e1 orr AND:e2 {:RESULT = IfPrograma.OR(e1, e2);:}
        | AND:e1 {:RESULT = e1;:}
;

AND ::= AND:e1 andd NOT:e2 {:RESULT = IfPrograma.AND(e1, e2);:}
        | NOT:e1 {:RESULT = e1;:}
;

NOT ::= nott NOT:e1 {:RESULT = IfPrograma.NOT(e1);:}
    | COMPARACION:e1 {:RESULT = new IfPrograma(new If_Operator(e1, new Etiqueta()), ((CondicionalOperator)e1).getTripletes());:}
    | para CONDICION:e1 parc {:RESULT = e1;:}
;

COMPARACION ::= OPERACION_A:e1 igig OPERACION_A:e2 {:RESULT = new IgualOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 noigual OPERACION_A:e2 {:RESULT = new NoIgualOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 menor OPERACION_A:e2 {:RESULT = new MenorOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 menorig OPERACION_A:e2 {:RESULT = new MenorIgOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 mayor OPERACION_A:e2 {:RESULT = new MayorOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 mayorig OPERACION_A:e2 {:RESULT = new MayorIgOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
;

LLAMADA_METODO ::= pyy punto id:e1 para LIST_PARAM:e2 parc {:MetodoPython met = sem.existeMetodoPY(e1, e2);
                        if(met == null){
                                reportarSem("Metodo de Python no existente con id: <" + e1 + ">");
                        } else {
                                List<Triplete> tri = new ArrayList<>();
                                tri.addAll(met.verMetodo(e2, sem.getVariables().getTamano()));
                                SumOperator s = new SumOperator(null, new P(), new TerminalOperator(""+sem.getVariables().getTamano()),"int");
                                tri.add(s);
                                AsignarTemporal ast = new AsignarTemporal(null, new Stack(s), "float");
                                OperacionPrograma op = new OperacionPrograma(CallPrograma.regresarTipo(met), ast);
                                op.getTripletes().addAll(tri);
                                RESULT = op;
                        }:}
                | vbb punto id:e1 para LIST_PARAM:e2 parc {:MetodoVisual met = sem.existeMetodoVB(e1, e2);
                        if(met == null){
                                reportarSem("Metodo de Visua Basic no existente con id: <" + e1 + ">");
                        } else {
                                List<Triplete> tri = new ArrayList<>();
                                tri.addAll(met.verMetodo(e2, sem.getVariables().getTamano()));
                                SumOperator s = new SumOperator(null, new P(), new TerminalOperator(""+sem.getVariables().getTamano()),"int");
                                tri.add(s);
                                AsignarTemporal ast = new AsignarTemporal(null, new Stack(s), "float");
                                OperacionPrograma op = new OperacionPrograma(CallPrograma.regresarTipo(met), ast);
                                op.getTripletes().addAll(tri);
                                RESULT = op;
                        }:}
                | javaa punto id:e1 punto id:e2 para LIST_PARAM:e3 parc {:
                        VariablePrograma objeto = sem.existeObjeto(e1);
                        if(objeto == null){
                                reportarSem("Variable que almacena un objeto de Java no existente con id: <" + e1 + ">");
                        } else {
                                MetodoJava met = sem.existeMetodoJV(objeto.getTip(), e2, e3);
                                if(met == null) {
                                        reportarSem("Metodo de Java no existente con id: <" + e2 + ">");
                                } else {
                                List<Triplete> tri = new ArrayList<>();
                                tri.addAll(met.verMetodo(sem.getVariables().getTamano(), objeto, e3));
                                SumOperator s = new SumOperator(null, new P(), new TerminalOperator(""+(sem.getVariables().getTamano()+1)),"int");
                                tri.add(s);
                                AsignarTemporal ast = new AsignarTemporal(null, new Stack(s), "float");
                                OperacionPrograma op = new OperacionPrograma(CallPrograma.regresarTipo(met), ast);
                                op.getTripletes().addAll(tri);
                                RESULT = op;}
                        }:}
                | error punto id para LIST_PARAM parc {:reportarSem("Llamada a metodo incorrecta, se esperaba PY|VB");:}
                | error punto id punto id para LIST_PARAM parc {:reportarSem("Llamada a metodo incorrecta, se esperaba JV");:}
                | pyy error id para LIST_PARAM parc {:reportarSem("Llamada a metodo py incorrecta, se esperaba un punto");:}
                | vbb error id para LIST_PARAM parc {:reportarSem("Llamada a metodo vb incorrecta, se esperaba un punto");:}
                | pyy punto error para LIST_PARAM parc {:reportarSem("Llamada a metodo py incorrecta, se esperaba un id");:}
                | vbb punto error para LIST_PARAM parc {:reportarSem("Llamada a metodo vb incorrecta, se esperaba un id");:}
                | pyy punto id error LIST_PARAM parc {:reportarSem("Llamada a metodo py incorrecta, se esperaba un (");:}
                | vbb punto id error LIST_PARAM parc {:reportarSem("Llamada a metodo vb incorrecta, se esperaba un (");:}
                | javaa error id punto id para LIST_PARAM parc {:reportarSem("Llamada a metodo java incorrecta, se esperaba un punto");:}
                | javaa punto error punto id para LIST_PARAM parc {:reportarSem("Llamada a metodo java incorrecta, se esperaba un id");:}
                | javaa punto id error id para LIST_PARAM parc {:reportarSem("Llamada a metodo java incorrecta, se esperaba un punto");:}
                | javaa punto id punto error para LIST_PARAM parc {:reportarSem("Llamada a metodo java incorrecta, se esperaba un id");:}
;

EXPR ::= LLAMADA_METODO:e1 {:if(!e1.getTipo().equals(Triplete.tipos[3])){RESULT = new OperacionPrograma(new AsignarTemporal(null, e1.getTriplete(),
                Triplete.devolverTipo(e1)), e1);} else {reportarSem("Error, metodo void no regresa ningun dato");}:}
        | OPERACION_A:e1 {:RESULT = e1;:}
        | getch {:RESULT = new OperacionPrograma(VariablePrograma.INT, new GetchOperator());:}
;

CLASS ::= javaa punto id:e1 LIST_CLASS:e2 puntocoma {:
        RESULT = new ListaTripletes(ObjetoPrograma.triplete(e1, e2, sem, ProgramaSemantica.AMBITO));:}
        | error punto id LIST_CLASS puntocoma {:reportarSem("Llamada a constructor java incorrecto, se esperaba la llamada jv"); RESULT = new ListaTripletes();:}
        | javaa error id LIST_CLASS puntocoma {:reportarSem("Llamada a constructor java incorrecto, se esperaba un punto"); RESULT = new ListaTripletes();:}
        | javaa punto error LIST_CLASS puntocoma {:reportarSem("Llamada a constructor java incorrecto, se esperaba un id"); RESULT = new ListaTripletes();:}
        | javaa punto id LIST_CLASS error {:reportarSem("Llamada a constructor java incorrecto, se esperaba un ;"); RESULT = new ListaTripletes();:}
;

LIST_CLASS ::= LIST_CLASS:e1 coma id:e2 PARAM:e3 {:ObjetoPrograma ob = new ObjetoPrograma(e2, e3);
            e1.add(ob); RESULT = e1;:}
            | id:e1 PARAM:e2 {:ObjetoPrograma ob = new ObjetoPrograma(e1, e2);
            List<ObjetoPrograma> pro = new ArrayList<>(); pro.add(ob);
            RESULT = pro;:}
            | LIST_CLASS coma error PARAM {:reportarSem("Error en objetos java, se esperaba un id para el objeto"); RESULT = new ArrayList<>();:}
;

PARAM ::= para LIST_PARAM:e1 parc {:RESULT = e1;:}
        | para error parc {:reportarSem("Error en parametros del constructor, se esperaban parametros"); RESULT = new ArrayList<>();:}
        | {:RESULT = new ArrayList<>();:}
;

LIST_PARAM ::= LIST:e1 {:RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

LIST ::= LIST:e1 coma OPERACION_A:e2 {:e1.add(e2); RESULT = e1;:}
        | OPERACION_A:e1 {:List<OperacionPrograma> params = new ArrayList<>(); params.add(e1); RESULT = params;:}
        | LIST error OPERACION_A {:reportarSem("Error en parametros de constructor, se esperaba una coma"); RESULT = new ArrayList<>();:}
;

OPERACION_AC ::= OPERACION_AC:e1 mas OPERACION_MC:e2 {:if(e1 != null && e2 != null){
                OperacionPrograma op = new OperacionPrograma(e1, e2, new SumOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));
                op.setValor(e1.getValor() - e2.getValor()); RESULT = op;}:}
        | OPERACION_AC:e1 menos OPERACION_MC:e2 {:if(e1 != null && e2 != null){
                OperacionPrograma op = new OperacionPrograma(e1, e2, new RestOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));
                op.setValor(e1.getValor() - e2.getValor()); RESULT = op;}:}
        | OPERACION_MC:e1 {:RESULT = e1;:}
;

OPERACION_MC ::= OPERACION_MC:e1 por OPERACION_UC:e2 {:if(e1 != null && e2 != null){
                OperacionPrograma op = new OperacionPrograma(e1, e2, new PorOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));
                op.setValor(e1.getValor() * e2.getValor()); RESULT = op;}:}
        | OPERACION_MC:e1 div OPERACION_UC:e2 {:if(e1 != null && e2 != null){
                OperacionPrograma op = new OperacionPrograma(e1, e2, new DivOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));
                op.setValor(e1.getValor()/e2.getValor()); RESULT = op;}:}
        | OPERACION_MC:e1 mod OPERACION_UC:e2 {:if(e1 != null && e2 != null){ 
                OperacionPrograma op = new OperacionPrograma(e1, e2, new ModOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));
                op.setValor(e1.getValor() % e2.getValor()); RESULT = op;}:}
        | OPERACION_UC:e1 {:RESULT = e1;:}
;

OPERACION_UC ::= menos OPERACION_UC:e1 {:if(e1 != null && e1.getTipo()==1){e1.setTipo(VariablePrograma.INT);}
                OperacionPrograma cero = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator("0"));
                OperacionPrograma op = new OperacionPrograma(cero, e1, new RestOperator(null, cero.getTriplete(), e1.getTriplete(), Triplete.devolverTipo(cero, e1)));
                op.setValor(e1.getValor()*-1); RESULT = op;:}
        | mas OPERACION_UC:e1 {:RESULT = e1;:}
        | ATOMC:e1 {:RESULT = e1;:}
;

// Falta resolver lo de los corchetes
ATOMC ::= id:e1 {:VariablePrograma var = sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)); 
                if(var == null || !var.isConstant()){
                        reportarSem("Variable no existente con el id: <" + e1 + ">");
                } else{
                        SumOperator sum = sem.getVariables().devolverSum(e1);
                        AsignarTemporal ast = new AsignarTemporal(null, sem.getVariables().devolverDireccion(sum), "float");
                        OperacionPrograma op = new OperacionPrograma(var.getTipo(), ast);
                        op.getTripletes().add(sum);
                        op.setValor(var.getValor());
                        RESULT = op;}:}
        | entero:e1 {:OperacionPrograma pro = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator(e1)); pro.setValor(Float.parseFloat(e1));
                        RESULT = pro;:}
        | decimal:e1 {:String s = ".LC" + Triplete.FLOAT;
                Triplete.FLOAT += 1;
                sem.getFl().add("\t.align 4");
                sem.getFl().add(s);
                sem.getFl().add("\t.long\t"+Float.floatToIntBits(Float.parseFloat(e1)));
                OperacionPrograma pro = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator(e1, s)); 
                pro.setValor(Float.parseFloat(e1));
                        RESULT = pro;:}
        | character:e1 {:OperacionPrograma pro = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator(e1)); pro.setValor((float)e1.charAt(1));
                        RESULT = pro;:}
        | para OPERACION_AC:e1 parc {:RESULT = e1;:}
;