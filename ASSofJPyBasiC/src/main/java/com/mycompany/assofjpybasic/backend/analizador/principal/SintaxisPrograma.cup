package com.mycompany.assofjpybasic.backend.analizador.principal;

import java_cup.runtime.*;
import com.mycompany.assofjpybasic.backend.semantica.programa.*;
import java.util.ArrayList;
import java.util.List;
import com.mycompany.assofjpybasic.backend.semantica.programa.cod3.*;
import com.mycompany.assofjpybasic.backend.semantica.python.*;
import com.mycompany.assofjpybasic.backend.semantica.java.*;
import com.mycompany.assofjpybasic.backend.semantica.visual.*;

class SintaxisPrograma;

parser code
{:
    private Symbol s;
    private ProgramaSemantica sem = new ProgramaSemantica();
    private boolean esCase = false;
    private String java, vb, py;
    
    public void syntax_error(Symbol sym){
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception{
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public void setTipo(String java, String vb, String py){
            this.java = java;
            this.vb = vb;
            this.py = py;
            sem.iniciarJAVA(this.java);
    }

    public Symbol getS(){
        return this.cur_token;
    }
:};

terminal String voidd, mainn, constt, intt, floatt, charr, asig, andd, orr, nott;
terminal String iff, elsee, forr, switchh, casee, whilee, defaultt, breakk, doo, includee;
terminal String noigual, menor, menorig, mayor, mayorig, igig, mas, menos, por, div, mod;
terminal String para, parc, llavea, llavec, cora, corc, coma, puntocoma, dosp, punto;
terminal String printf, scanf, clrs, getch, igual, masmas, menosmenos, java, py, vb;
terminal String com, idlib, id, entero, decimal, character, comilla;
terminal String pyy, vbb, javaa;
terminal String string, str;

non terminal INCLUDE_LENG, IN_LENG, CONST, VARGLOB;
non terminal MAIN;
non terminal Integer TYPE;
non terminal List<VariablePrograma> LIST_ASIG, ASIG_VAR;
non terminal OperacionPrograma EXPR, ASIG, OPERACION_A, OPERACION_M, OPERACION_U, ATOM, LLAMADA_METODO;
non terminal List<OperacionPrograma> CORCHETES, LIST_PARAM, LIST, PARAM;
non terminal String IN_CLASS;
non terminal Triplete COMPARACION;
non terminal CondicionPrograma NOT, AND, CONDICION;
non terminal List<Triplete> PRINTF, SCANF, DEF_VAR, STATEMENTLINE, STATEMENTS, STATEMENT, COMPOUND, SWITCH;
non terminal List<Triplete> OP_VAR, STEP, INICIO, IF_ELSE, ELSE, WHILE, DO_WHILE, FOR, STATEMENTSC, DEFAULT, CLASS;
non terminal List<TerminalOperator> VARSS;
non terminal List<OperacionPrograma> VARS;
non terminal List<String> STRING;
non terminal String STR;
non terminal Else_Operator ELSE_IF;
non terminal CasePrograma CASES;
non terminal String PROGRAMA;
non terminal List<ObjetoPrograma> LIST_CLASS;

start with PROGRAMA;

PROGRAMA ::= INCLUDE_LENG CONST MAIN {:RESULT = sem.mostrarCodigo();:}
;

INCLUDE_LENG ::= INCLUDE_LENG IN_LENG
        | 
;

IN_LENG ::= py {:sem.iniciarPY(py);:}
        | vb {:sem.iniciarVB(vb);:}
        | java IN_CLASS:e1 comilla {:if(e1.equals("$$*$$")){sem.importarTodasClases();}else{sem.importarClase(e1);}:}
        | includee:e1 idlib:e2 {:sem.getImports().add(e1 + " " + e2);:}
;

IN_CLASS ::= por {:RESULT = "$$*$$";:}
        | id:e1 {:RESULT = e1;:}
;

CONST ::= CONST constt TYPE:e1 id:e2 igual EXPR:e3 puntocoma 
        {:if(!sem.addVar(new ConstantePrograma(e2,ProgramaSemantica.AMBITO, e1, e3.getTipo(), null))){
              syntax_error(getS());
        } else {sem.getVar().addAll(e3.mostrarTripletes());
                sem.getVar().add(new AsignarConstante(new TerminalOperator(e2), e3.getTriplete(), Triplete.tipos[e1-1]));}:}
        | CONST ASIG_VAR:e1 {:List<Triplete> tri = new ArrayList<>();
                        for(VariablePrograma var : e1){
                        tri.addAll(var.mostrarTripletes());
                        } sem.getVar().addAll(tri);:}
        | {::}
;

TYPE ::= intt {:RESULT = VariablePrograma.INT;:}
        | floatt {:RESULT = VariablePrograma.FLOAT;:}
        | charr {:RESULT = VariablePrograma.CHAR;:}
;

/*VARGLOB ::= VARGLOB ASIG_VAR
        |
;*/

ASIG_VAR ::= TYPE:e1 LIST_ASIG:e2 puntocoma {:if(!sem.addListVar(e2, e1)){syntax_error(getS());
                RESULT = new ArrayList<>();}
                else {for(VariablePrograma var : e2){
                        var.setTipo(e1);
                        if(var.getTriplete() instanceof AsignarValor)
                        ((AsignarValor)var.getTriplete()).setTipo(Triplete.tipos[e1-1]);
                } RESULT = e2;}:}
        | TYPE:e1 id:e2 CORCHETES:e4 puntocoma {: List<VariablePrograma> var = new ArrayList<>();
                ArregloPrograma arr = new ArregloPrograma(e2, ProgramaSemantica.AMBITO, e1, e4, 
                new DefinirArreglo(null, new TerminalOperator(e2), Triplete.tipos[e1-1]));
                if(!sem.addVar(arr)){
                        syntax_error(getS());
                }else {var.add(arr);} RESULT = var;:}
;

CORCHETES ::= CORCHETES:e1 cora EXPR:e2 corc {:if(e2.getTipo()<=VariablePrograma.INT) e1.add(e2); RESULT = e1;:}
        | cora EXPR:e1 corc {:List<OperacionPrograma> opr = new ArrayList<>(); 
                if(e1.getTipo()<=VariablePrograma.INT) opr.add(e1);
                RESULT = opr;:}
;

LIST_ASIG ::= LIST_ASIG:e1 coma id:e2 ASIG:e3 {:
                if(e3!=null) e1.add(new VariablePrograma(e2, ProgramaSemantica.AMBITO, e3,
                new AsignarValor(null, new TerminalOperator(e2), e3.getTriplete())));
                else e1.add(new VariablePrograma(e2, ProgramaSemantica.AMBITO,
                new AsignarValor("", new TerminalOperator(e2), null))); RESULT = e1;:}
            | id:e1 ASIG:e2 {:List<VariablePrograma> vars = new ArrayList<>();
            if(e2!=null) vars.add(new VariablePrograma(e1, ProgramaSemantica.AMBITO, e2,
                new AsignarValor(null, new TerminalOperator(e1), e2.getTriplete()))); 
            else vars.add(new VariablePrograma(e1, ProgramaSemantica.AMBITO,
                new AsignarValor("", new TerminalOperator(e1), null))); RESULT = vars;:}
;

ASIG ::= igual EXPR:e1 {:RESULT = e1;:}
        |
;

OPERACION_A ::= OPERACION_A:e1 mas OPERACION_M:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new SumOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 menos OPERACION_M:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new RestOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 {:RESULT = e1;:}
;

OPERACION_M ::= OPERACION_M:e1 por OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new PorOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 div OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new DivOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 mod OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new ModOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_U:e1 {:RESULT = e1;:}
;

OPERACION_U ::= menos OPERACION_U:e1 {:if(e1 != null && e1.getTipo()==1){e1.setTipo(VariablePrograma.INT);}
                OperacionPrograma cero = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator("0"));
                RESULT = new OperacionPrograma(cero,
                e1, new RestOperator(null, cero.getTriplete(), e1.getTriplete(),
                Triplete.devolverTipo(cero, e1)));:}
        | mas OPERACION_U:e1 {:RESULT = e1;:}
        | ATOM:e1 {:RESULT = e1;:}
;

// Falta resolver lo de los corchetes
ATOM ::= id:e1 {:VariablePrograma var = sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)); 
                if(var == null){
                        syntax_error(getS());
                } else{RESULT = new OperacionPrograma(var.getTipo(), new TerminalOperator(e1));}:}
        | entero:e1 {:RESULT = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator(e1));:}
        | decimal:e1 {:RESULT = new OperacionPrograma(VariablePrograma.FLOAT, new TerminalOperator(e1));:}
        | character:e1 {:RESULT = new OperacionPrograma(VariablePrograma.CHAR, new TerminalOperator(e1));:}
        | id:e1 CORCHETES:e2 {:VariablePrograma var = sem.existeVar(e1, e2.size());
                if(var == null){syntax_error(getS());}else {OperacionPrograma arr = new ArregloPrograma(var.getId(), ProgramaSemantica.AMBITO,
                var.getTipo(), e2, (ArregloPrograma) var); arr.mostrarTripletes();
                OperacionPrograma corch = new OperacionPrograma(var.getTipo(), new TemporalArreglo(null, e1, 
                arr.getTriplete(),Triplete.tipos[var.getTipo()-1])); corch.getTripletes().addAll(0, arr.getTripletes()); 
                RESULT = corch;}
                :}
        | para OPERACION_A:e1 parc {:RESULT = e1;:}
;

MAIN ::= voidd mainn para parc llavea STATEMENTS:e1 llavec {:sem.getTripletes().addAll(e1);:}
;

STATEMENTS ::= STATEMENT:e1 STATEMENTS:e2 {:e1.addAll(e2); RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

STATEMENT ::= COMPOUND:e1 {:RESULT = e1;:}
        | STATEMENTLINE:e1 {:RESULT = e1;:}
;

COMPOUND ::= WHILE:e1 {:RESULT = e1;:}
        | DO_WHILE:e1 {:RESULT = e1;:}
        | FOR:e1 {:RESULT = e1;:}
        | IF_ELSE:e1 {:RESULT = e1;:}
        | SWITCH:e1 {:RESULT = e1;:}
;

STATEMENTLINE ::= clrs puntocoma {:List<Triplete> tr = new ArrayList<>(); tr.add(new Clrs()); RESULT = tr;:}
        | ASIG_VAR:e1 {:List<Triplete> tri = new ArrayList<>();
                        for(VariablePrograma var : e1){
                        tri.addAll(var.mostrarTripletes());
                        } RESULT = tri;:}
        | DEF_VAR:e1 puntocoma {:RESULT = e1;:}
        | PRINTF:e1 {:RESULT = e1;:}
        | SCANF:e1 {:RESULT = e1;:}
        | LLAMADA_METODO:e1 puntocoma {:List<Triplete> tri = new ArrayList<>();
                if(e1 != null) {tri.addAll(e1.mostrarTripletes());
                tri.add(e1.getTriplete());}
                RESULT = tri;:}
        | getch puntocoma {:List<Triplete> tr = new ArrayList<>(); tr.add(new GetchOperator()); RESULT = tr;:}
        | CLASS:e1 {:RESULT = e1;:}
;

DEF_VAR ::= id:e1 igual EXPR:e2 {:List<Triplete> tri = new ArrayList<>(); 
                if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)) == null || e2 == null) {
                        syntax_error(getS());
                } else {AsignarValor asig = new AsignarValor(null, new TerminalOperator(e1), e2.getTriplete());
                        tri.addAll(e2.mostrarTripletes());
                        tri.add(asig);} RESULT = tri;:}
        | id:e1 CORCHETES:e2 igual EXPR:e3 {:VariablePrograma var = sem.existeVar(e1, e2.size());
                if(var == null){syntax_error(getS());}else {OperacionPrograma arr = new ArregloPrograma(var.getId(), ProgramaSemantica.AMBITO,
                var.getTipo(), e2, (ArregloPrograma) var, e3); RESULT = arr.mostrarTripletes(); }:}
;

PRINTF ::= printf para comilla STRING:e1 comilla VARS:e2 parc puntocoma 
                {:if(e1 != null) RESULT = Printf.regresarTripletes(e1, e2);:}
;

/*STRING ::= comilla STR comilla
;

STR ::= STR txt
        | STR MASCARA
        | txt
        | MASCARA
;

MASCARA ::= intpor
        | floatpor
        | charpor
;*/

STRING ::= STRING:e1 string:e2 {:e1.add(e2); RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

VARS ::= VARS:e1 coma OPERACION_A:e2 {:if(e1!=null && e2!= null){e1.add(e2); RESULT = e1;}:}
        | {:List<OperacionPrograma> op = new ArrayList<>(); RESULT = op;:}
;

SCANF ::= scanf para comilla STRING:e1 comilla VARSS:e2 parc puntocoma 
                {:if(e2!=null) RESULT = Scanf.regresarTripletes(e1, e2);:}
;

VARSS ::= VARSS:e2 coma asig id:e1 {:if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)) == null
                                || e2 == null){
                        syntax_error(getS());
                } else {e2.add(new TerminalOperator(e1)); RESULT = e2;}:}
        | {:List<TerminalOperator> arr = new ArrayList<>(); RESULT = arr;:}
;

IF_ELSE ::= iff para CONDICION:e1 parc llavea {:ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS:e2 llavec ELSE_IF:e3 ELSE:e4 {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                e3.agregarIf(e1, e2); RESULT = e3.juntarTripletes(e4);:}
;

ELSE_IF ::= ELSE_IF:e1 elsee iff para CONDICION:e2 parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e3 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1.agregarElseIf(e2, e3);:}
        | {:RESULT = new Else_Operator();:}
;

ELSE ::= elsee llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e1 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

SWITCH ::= switchh para EXPR:e1 parc llavea CASES:e2 DEFAULT:e3 llavec {:RESULT = e2.agregarDefault(e1, e3);:}
;

CASES ::= CASES:e1 casee OPERACION_A:e2 dosp {:esCase = true; ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTSC:e3 {:esCase = false; sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                if(e2!=null){RESULT  = e1.agregarCase(e2, e3);}:}
        | {:RESULT = new CasePrograma();:}
;

STATEMENTSC ::= STATEMENT:e1 STATEMENTSC:e2 {:e1.addAll(e2); RESULT = e1;:}
        | breakk puntocoma {:List<Triplete> tri = new ArrayList<>(); 
                if(!esCase){syntax_error(getS());}else{tri.add(new Break());} RESULT = tri;:}
        | {:RESULT = new ArrayList<>();:}
;

DEFAULT ::= defaultt dosp {:esCase = true; ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTSC:e1 {:esCase = false; sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
                RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

WHILE ::= whilee para CONDICION:e1 parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e2 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
        RESULT = Else_Operator.WHILE(e1, e2);:}
;

DO_WHILE ::= doo llavea {:ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS:e1 llavec whilee para CONDICION:e2 parc {:sem.eliminarAmbito(ProgramaSemantica.AMBITO);
        ProgramaSemantica.AMBITO -= 1; RESULT = Else_Operator.DOWHILE(e2, e1);:}
;

FOR ::= forr para INICIO:e1 puntocoma CONDICION:e2 puntocoma STEP:e3 parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS:e5 llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;
        RESULT = Else_Operator.FOR(e1, e3, e2, e5);:}
;

INICIO ::= DEF_VAR:e1 {:RESULT = e1;:}
        | id:e1 {:if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null))== null){
                syntax_error(getS());
                }RESULT = new ArrayList<>();:}
        | TYPE:e2 id:e1 igual EXPR:e3 {:List<Triplete> tri = new ArrayList<>();
        if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)) != null){
                syntax_error(getS());
        } else {tri.addAll(e3.getTripletes()); tri.add(e3.getTriplete());
                tri.add(new AsignarValor(new TerminalOperator(e1), e3.getTriplete(), Triplete.tipos[e2-1]));}:}
;

STEP ::= DEF_VAR:e1 {:RESULT = e1;:}
        | OP_VAR:e1 {:RESULT = e1;:}
;

OP_VAR ::= id:e1 masmas {:List<Triplete> tri = new ArrayList<>(); VariablePrograma vars = new VariablePrograma(e1, ProgramaSemantica.AMBITO, null);
                if(vars == null){
                        syntax_error(getS());
                } else {tri.add(new SumOperator(null, new TerminalOperator(e1), new TerminalOperator("1"), Triplete.tipos[vars.getTipo()-1]));
                        tri.add(new AsignarValor(null, new TerminalOperator(e1), tri.get(0)));
                } RESULT = tri;:}
        | id:e1 menosmenos {:List<Triplete> tri = new ArrayList<>(); VariablePrograma vars = new VariablePrograma(e1, ProgramaSemantica.AMBITO, null);
                if(vars == null){
                        syntax_error(getS());
                } else {tri.add(new SumOperator(null, new TerminalOperator(e1), new TerminalOperator("1"), Triplete.tipos[vars.getTipo()-1]));
                        tri.add(new AsignarValor(null, new TerminalOperator(e1), tri.get(0)));
                } RESULT = tri;:}
;

CONDICION ::= CONDICION:e1 orr AND:e2 {:RESULT = IfPrograma.OR(e1, e2);:}
        | AND:e1 {:RESULT = e1;:}
;

AND ::= AND:e1 andd NOT:e2 {:RESULT = IfPrograma.AND(e1, e2);:}
        | NOT:e1 {:RESULT = e1;:}
;

NOT ::= nott NOT:e1 {:RESULT = IfPrograma.NOT(e1);:}
    | COMPARACION:e1 {:RESULT = new IfPrograma(new If_Operator(e1, new Etiqueta()), ((CondicionalOperator)e1).getTripletes());:}
    | para CONDICION:e1 parc {:RESULT = e1;:}
;

COMPARACION ::= OPERACION_A:e1 igig OPERACION_A:e2 {:RESULT = new IgualOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 noigual OPERACION_A:e2 {:RESULT = new NoIgualOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 menor OPERACION_A:e2 {:RESULT = new MenorOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 menorig OPERACION_A:e2 {:RESULT = new MenorIgOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 mayor OPERACION_A:e2 {:RESULT = new MayorOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
    | OPERACION_A:e1 mayorig OPERACION_A:e2 {:RESULT = new MayorIgOperator(e1.getTriplete(), e2.getTriplete(),
                e1.getTripletes(), e2.getTripletes());:}
;

LLAMADA_METODO ::= pyy punto id:e1 para LIST_PARAM:e2 parc {:MetodoPython met = sem.existeMetodoPY(e1, e2);
                        if(met == null){
                                syntax_error(getS());
                        } else {
                                RESULT = new CallPrograma(e2,
                                new CallMetodo(CallPrograma.regresarPy(met)),
                                CallPrograma.regresarTipo(met));
                        }:}
                | vbb punto id:e1 para LIST_PARAM:e2 parc {:MetodoVisual met = sem.existeMetodoVB(e1, e2);
                        if(met == null){
                                syntax_error(getS());
                        } else {
                                RESULT = new CallPrograma(e2,
                                new CallMetodo(CallPrograma.regresarVB(met)),
                                CallPrograma.regresarTipo(met));
                        }:}
                | javaa punto id:e1 punto id:e2 para LIST_PARAM:e3 parc {:
                        String objeto = sem.existeObjeto(e1);
                        MetodoJava met = sem.existeMetodoJV(objeto, e2, e3);
                        if(met == null){
                                syntax_error(getS());
                        } else {
                                RESULT = new CallPrograma(e3,
                                new CallMetodo(CallPrograma.regresarJava(met, e1)),
                                CallPrograma.regresarTipo(met));
                        }:}
;

EXPR ::= LLAMADA_METODO:e1 {:RESULT = new OperacionPrograma(new AsignarTemporal(null, e1.getTriplete(),
                Triplete.devolverTipo(e1)), e1);:}
        | OPERACION_A:e1 {:RESULT = e1;:}
        | getch {:RESULT = new OperacionPrograma(VariablePrograma.INT, new GetchOperator());:}
;

CLASS ::= javaa punto id:e1 LIST_CLASS:e2 puntocoma {:RESULT = ObjetoPrograma.triplete(e1, e2, sem, ProgramaSemantica.AMBITO);:}
;

LIST_CLASS ::= LIST_CLASS:e1 coma id:e2 PARAM:e3 {:ObjetoPrograma ob = new ObjetoPrograma(e2, e3);
            e1.add(ob); RESULT = e1;:}
            | id:e1 PARAM:e2 {:ObjetoPrograma ob = new ObjetoPrograma(e1, e2);
            List<ObjetoPrograma> pro = new ArrayList<>(); pro.add(ob);
            RESULT = pro;:}
;

PARAM ::= para LIST_PARAM:e1 parc {:RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

LIST_PARAM ::= LIST:e1 {:RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

LIST ::= LIST_PARAM:e1 coma OPERACION_A:e2 {:e1.add(e2); RESULT = e1;:}
        | OPERACION_A:e1 {:List<OperacionPrograma> params = new ArrayList<>(); params.add(e1); RESULT = params;:}
;