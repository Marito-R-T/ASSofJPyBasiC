package com.mycompany.assofjpybasic.backend.analizador.java;

import java_cup.runtime.*;
import com.mycompany.assofjpybasic.backend.semantica.java.*;
import java.util.ArrayList;
import java.util.List;

class SintaxisJava;

parser code
{:
    private Symbol s;
    private JavaSemantica java = new JavaSemantica();
    private TablaJava tabla;
    private List<VariableJava> variables;
    int ret = 4;
    int cas = 0;
    
    public void syntax_error(Symbol sym){
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception{
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public Symbol getS(){
        return this.cur_token;
    }
:};

terminal String publicc, classs, voidd, intt, floatt, charr, andd, orr, nott, iff, elsee, com;
terminal String forr, whilee, doo, switchh, casee, dosp, defaultt, returnn, thiss, punto, breakk;
terminal String noigual, menor, menorig, mayor, mayorig, igig, mas, menos, por, div, mod;
terminal String para, parc, llavea, llavec, coma, puntocoma, println, print, charinput, intinput, floatinput;
terminal String igual, masmas, menosmenos, id, entero, decimal, character, string;

non terminal JAVA, CLASSES, CLASS, STATEMENTS_CLASS, STATEMENT_CLASS, METODO;
non terminal Integer TYPE_V, TYPE;
non terminal Boolean THIS;
non terminal List<VariableJava> LIST_PAR;
non terminal OperacionJava OPERACION_A, OPERACION_M, OPERACION_U, ATOM, EXPR, INPUT;
non terminal LIST_PARR, DEF_VAR, LIST_VAR, AS_VAR;
non terminal WHILE, FOR, INICIO, STEP, DO_WHILE, SWITCH, CASES;
non terminal CASE, DEFAULT, WRITE, OP_VAR, EXPR_STRING;
non terminal CONDICION, AND, NOT, COMPARACION, STRING, AS_VAR_LINE;
non terminal ReturnJava RETURN;
non terminal StatementJava STATEMENT_METODO, COMP_STATE, STATEMENT_LINE;
non terminal StatementsJava STATEMENTS_METODO, BLOQUE;
non terminal IfOperacion ELSE;
non terminal ListaIf IF_ELSE, ELSEIF;

start with JAVA;

JAVA ::= CLASSES
;

CLASSES ::= CLASSES CLASS
        | 
;

CLASS ::= publicc classs id:e1 llavea {:TablaJava sem = new TablaJava(e1); if(!java.agregarTabla(sem)){
                                syntax_error(getS()); }
                                tabla = sem; TablaJava.AMBITO += 1;:} 
        STATEMENTS_CLASS llavec {:tabla.eliminarAmbito(TablaJava.AMBITO); TablaJava.AMBITO -= 1; tabla = null;:}
;

STATEMENTS_CLASS ::= STATEMENTS_CLASS STATEMENT_CLASS
        | {::}
;

STATEMENT_CLASS ::= METODO
        | DEF_VAR puntocoma
;

METODO ::= publicc TYPE_V:e1 id:e2 para LIST_PAR:e3 parc llavea {:ret = e1;
                if(!tabla.addMetodo(new MetodoJava(e2, e1, e3))){
                        syntax_error(getS());
                }
                        TablaJava.AMBITO += 1;:}
                STATEMENTS_METODO:e4 llavec {:tabla.eliminarAmbito(TablaJava.AMBITO); TablaJava.AMBITO -= 1;
                if(!e4.isRet() && ret!=4){syntax_error(getS());} ret = 4;:}
;

TYPE_V ::= voidd {:RESULT = TablaJava.VOID;:}
        | TYPE:e1 {:RESULT = e1;:}
;

TYPE ::= intt {:RESULT = TablaJava.INT;:}
        | floatt {:RESULT = TablaJava.FLOAT;:}
        | charr {:RESULT = TablaJava.CHAR;:}
;

LIST_PAR ::= TYPE:e1 id:e2 LIST_PARR {:tabla.getVariables().add(0, new VariableJava(e2, e1, TablaJava.AMBITO+1));:}
        |
;

LIST_PARR ::= coma TYPE:e1 id:e2 LIST_PARR {:tabla.getVariables().add(0, new VariableJava(e2, e1, TablaJava.AMBITO+1));:}
        | 
;

STATEMENTS_METODO ::= STATEMENT_METODO:e1 STATEMENTS_METODO:e2 {:if(e2 != null) {e2.add(0, e1); 
                        if(e1 instanceof ListaIf && ((ListaIf)e1).isRet() && e2.isRet()){syntax_error(getS());} RESULT = e2;}
                        else{StatementsJava states = new StatementsJava(); states.add(e1);
                        if(e1 instanceof ListaIf){states.setRet(((ListaIf)e1).isRet());} RESULT = states;}:}
        | RETURN:e1 {:StatementsJava states = new StatementsJava(); states.setRet(true); states.add(e1); RESULT = states;:}
        | breakk puntocoma {:if(cas==0){syntax_error(getS());}:}
        | {:RESULT = null;:}
;

RETURN ::= returnn EXPR:e1 puntocoma {:if(e1==null || e1.getTipo() != ret){syntax_error(getS()); RESULT = null;}
                                        else{RESULT = new ReturnJava();}:}
;

STATEMENT_METODO ::= COMP_STATE:e1 {:RESULT = e1;:}
        | STATEMENT_LINE:e1 {:RESULT = new StatementJava();:}
;

DEF_VAR ::= TYPE:e1 {:variables = new ArrayList<>();:} LIST_VAR {:VariableJava.agregarTipo(variables, e1);
                        if(!tabla.addListVar(variables)){syntax_error(getS());} variables = new ArrayList<>();:}
;

LIST_VAR ::= LIST_VAR coma AS_VAR {::}
        | AS_VAR {::}
;

AS_VAR ::= id:e1 igual EXPR {:variables.add(new VariableJava(e1, TablaJava.AMBITO));:}
        | id:e1 {:variables.add(new VariableJava(e1, TablaJava.AMBITO));:}
;

COMP_STATE ::= WHILE {:RESULT = new StatementJava();:}
        | FOR {:RESULT = new StatementJava();:}
        | DO_WHILE {:RESULT = new StatementJava();:}
        | IF_ELSE:e1 {:RESULT = e1;:}
        | SWITCH {:RESULT = new StatementJava();:}
;

WHILE ::= whilee para CONDICION parc BLOQUE
;

BLOQUE ::= llavea {:TablaJava.AMBITO += 1;:}  STATEMENTS_METODO:e1 llavec {:tabla.eliminarAmbito(TablaJava.AMBITO); TablaJava.AMBITO -= 1;
                                                if(e1!=null){RESULT = e1;}else{RESULT = new StatementsJava();}:}
        | STATEMENT_LINE:e1 {:RESULT = null;:}
;

FOR ::= forr para INICIO puntocoma CONDICION puntocoma STEP parc BLOQUE
;

INICIO ::= THIS:e0 id:e1 {:int num; if(e0){num = tabla.existeVarGlobal(new VariableJava(e1, TablaJava.AMBITO));}
                        else {num = tabla.existeVar(new VariableJava(e1, TablaJava.AMBITO));}
                        if(num == -1){syntax_error(getS());}else{RESULT = new OperacionJava(num);}:}
        | TYPE:e1 {:TablaJava.AMBITO += 1; variables = new ArrayList<>();:} 
                AS_VAR {:if(!tabla.addListVar(variables)){syntax_error(getS());} TablaJava.AMBITO -= 1;:}
;

STEP ::= AS_VAR_LINE
        | OP_VAR
;

DO_WHILE ::= doo BLOQUE whilee para CONDICION parc puntocoma
;

IF_ELSE ::= iff para CONDICION parc BLOQUE:e2 ELSEIF:e3 ELSE:e4 {:IfOperacion op = new IfOperacion(e2); e3.getIfs().add(0, op);
                                        if(e4 != null){e3.getIfs().add(e4); e3.verRetornabilidad();}else{e3.setRet(false);} RESULT = e3;:}
;

ELSEIF ::= ELSEIF:e1 elsee iff para CONDICION parc BLOQUE:e3 {:IfOperacion op = new IfOperacion(e3);
                                e1.getIfs().add(op); RESULT = e1;:}
        | {:RESULT = new ListaIf();:}
;

ELSE ::= elsee BLOQUE:e1 {:IfOperacion op = new IfOperacion(e1); RESULT = op;:}
        | {:RESULT = null;:}
;

SWITCH ::= switchh para EXPR parc llavea CASES DEFAULT llavec
;

CASES ::= CASES CASE
        | 
;

CASE ::= casee OPERACION_A dosp {:cas++;:} STATEMENTS_METODO {:cas--;:}
;

DEFAULT ::= defaultt dosp {:cas++;:} STATEMENTS_METODO {:cas--;:}
        |
;

STATEMENT_LINE ::= AS_VAR_LINE puntocoma
        | DEF_VAR puntocoma
        | WRITE puntocoma
        | INPUT puntocoma
;

AS_VAR_LINE ::= THIS:e0 id:e1 igual EXPR:e2 {:int num = tabla.existeVar(new VariableJava(e1, TablaJava.AMBITO)); 
                                        if(num==-1 || num<e2.getTipo()){syntax_error(getS());}:}
;

WRITE ::= println para STRING parc
       | print para STRING parc
;

OP_VAR ::= THIS:e0 id:e1 masmas {:int num; if(e0){num = tabla.existeVarGlobal(new VariableJava(e1, TablaJava.AMBITO));}
                        else {num = tabla.existeVar(new VariableJava(e1, TablaJava.AMBITO));}
                        if(num == -1){syntax_error(getS());}else{RESULT = new OperacionJava(num);}:}
        | THIS:e0 id:e1 menosmenos {:int num; if(e0){num = tabla.existeVarGlobal(new VariableJava(e1, TablaJava.AMBITO));}
                        else {num = tabla.existeVar(new VariableJava(e1, TablaJava.AMBITO));}
                        if(num == -1){syntax_error(getS());}else{RESULT = new OperacionJava(num);}:}
;

OPERACION_A ::= OPERACION_A:e1 mas OPERACION_M:e2 {:if(e1!=null&&e2!=null){
                        RESULT = new OperacionJava(TablaJava.regresarTipo(e1.getTipo(), e2.getTipo()));}:}
        | OPERACION_M:e1 menos OPERACION_M:e2 {:if(e1!=null&&e2!=null){
                        RESULT = new OperacionJava(TablaJava.regresarTipo(e1.getTipo(), e2.getTipo()));}:}
        | OPERACION_M:e1 {:RESULT = e1;:}
;

OPERACION_M ::= OPERACION_M:e1 por OPERACION_U:e2 {:if(e1!=null&&e2!=null){
                                RESULT = new OperacionJava(TablaJava.regresarTipo(e1.getTipo(), e2.getTipo()));}:}
        | OPERACION_M:e1 div OPERACION_U:e2 {:if(e1!=null&&e2!=null){
                                RESULT = new OperacionJava(TablaJava.regresarTipo(e1.getTipo(), e2.getTipo()));}:}
        | OPERACION_M:e1 mod OPERACION_U:e2 {:if(e1!=null&&e2!=null){
                                RESULT = new OperacionJava(TablaJava.regresarTipo(e1.getTipo(), e2.getTipo()));}:}
        | OPERACION_U:e1 {:RESULT = e1;:}
;

OPERACION_U ::= menos OPERACION_U:e1 {:if(e1.getTipo()==1){e1.setTipo(TablaJava.INT); RESULT = e1;} RESULT = e1;:}
        | mas OPERACION_U:e1 {:RESULT = e1;:}
        | ATOM:e1 {:RESULT = e1;:}
;

ATOM ::= THIS:e0 id:e1 {:int num; if(e0){num = tabla.existeVarGlobal(new VariableJava(e1, TablaJava.AMBITO));}
                        else {num = tabla.existeVar(new VariableJava(e1, TablaJava.AMBITO));}
                        if(num == -1){syntax_error(getS());}else{RESULT = new OperacionJava(num);}:}
        | entero {:RESULT = new OperacionJava(TablaJava.INT);:}
        | decimal {:RESULT = new OperacionJava(TablaJava.FLOAT);:}
        | character {:RESULT = new OperacionJava(TablaJava.CHAR);:}
        | para OPERACION_A:e1 parc {:RESULT = e1;:}
;

THIS ::= thiss punto {:RESULT = true;:}
        | {:RESULT = false;:}
;

CONDICION ::= CONDICION orr AND
        | AND
;

AND ::= AND andd NOT
        | NOT
;

NOT ::= nott NOT
    | COMPARACION
;

COMPARACION ::= OPERACION_A igig OPERACION_A
    | OPERACION_A noigual OPERACION_A
    | OPERACION_A menor OPERACION_A
    | OPERACION_A menorig OPERACION_A
    | OPERACION_A mayor OPERACION_A
    | OPERACION_A mayorig OPERACION_A
    | para CONDICION parc
;

STRING ::= STRING mas EXPR_STRING
        | EXPR_STRING
;

EXPR_STRING ::= string
        | character
        | entero
        | decimal
        | id:e1 {:int num = tabla.existeVar(new VariableJava(e1, TablaJava.AMBITO)); if(num == -1){syntax_error(getS());}:}
        | para OPERACION_A parc
;

EXPR ::= OPERACION_A:e1 {:RESULT = e1;:}
        | INPUT:e1 {:RESULT = e1;:}
;

INPUT ::= charinput para string parc {:RESULT = new OperacionJava(TablaJava.CHAR);:}
        | intinput para string parc {:RESULT = new OperacionJava(TablaJava.INT);:}
        | floatinput para string parc {:RESULT = new OperacionJava(TablaJava.FLOAT);:}
;