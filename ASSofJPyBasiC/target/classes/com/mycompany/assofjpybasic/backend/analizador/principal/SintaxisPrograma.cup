package com.mycompany.assofjpybasic.backend.analizador.principal;

import java_cup.runtime.*;
import com.mycompany.assofjpybasic.backend.semantica.programa.*;
import java.util.ArrayList;
import java.util.List;
import com.mycompany.assofjpybasic.backend.semantica.programa.cod3.*;

class SintaxisPrograma;

parser code
{:
    private Symbol s;
    private ProgramaSemantica sem = new ProgramaSemantica();
    private boolean esCase = false;
    private String java, vb, py;
    private List<Triplete> trip = new ArrayList<>();
    
    public void syntax_error(Symbol sym){
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception{
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public void setTipo(String java, String vb, String py){
            this.java = java;
            this.vb = vb;
            this.py = py;
            sem.iniciarJAVA(this.java);
    }

    public Symbol getS(){
        return this.cur_token;
    }
:};

terminal String voidd, mainn, constt, intt, floatt, charr, asig, andd, orr, nott;
terminal String iff, elsee, forr, switchh, casee, whilee, defaultt, breakk, doo, includee;
terminal String noigual, menor, menorig, mayor, mayorig, igig, mas, menos, por, div, mod;
terminal String para, parc, llavea, llavec, cora, corc, coma, puntocoma, dosp, punto;
terminal String printf, scanf, clrs, getch, igual, masmas, menosmenos, java, py, vb;
terminal String com, idlib, id, entero, decimal, character, comilla, string;
terminal String pyy, vbb, javaa;

non terminal PROGRAMA, INCLUDE_LENG, IN_LENG, CONST, VARGLOB;
non terminal MAIN, STATEMENTS, STATEMENT;
non terminal COMPOUND, STATEMENTLINE, DEF_VAR, PRINTF, VARS, SCANF;
non terminal VARSS, IF_ELSE, ELSE_IF, ELSE, SWITCH, CASES, CASE, DEFAULT, WHILE, DO_WHILE, FOR, INICIO;
non terminal STEP, OP_VAR, CONDICION, AND, NOT, COMPARACION, LLAMADA_METODO, CLASS;
non terminal LIST_CLASS, PARAM;
non terminal Integer TYPE;
non terminal List<VariablePrograma> LIST_ASIG, ASIG_VAR;
non terminal OperacionPrograma EXPR, ASIG, OPERACION_A, OPERACION_M, OPERACION_U, ATOM;
non terminal List<OperacionPrograma> CORCHETES, LIST_PARAM, LIST;
non terminal String IN_CLASS;

start with PROGRAMA;

PROGRAMA ::= INCLUDE_LENG CONST VARGLOB MAIN
;

INCLUDE_LENG ::= INCLUDE_LENG IN_LENG
        | 
;

IN_LENG ::= py {:sem.iniciarPY(py);:}
        | vb {:sem.iniciarVB(vb);:}
        | java IN_CLASS:e1 comilla {:if(e1.equals("$$*$$")){sem.importarTodasClases();}else{sem.importarClase(e1);}:}
        | includee:e1 menor idlib:e2 mayor
;

IN_CLASS ::= por {:RESULT = "$$*$$";:}
        | id:e1 {:RESULT = e1;:}
;

CONST ::= CONST constt TYPE:e1 id:e2 igual EXPR:e3 puntocoma 
        {:if(!sem.addVar(new ConstantePrograma(e2,ProgramaSemantica.AMBITO, e1, e3.getTipo(), null))){
              syntax_error(getS());
        }:}
        | {::}
;

TYPE ::= intt {:RESULT = VariablePrograma.INT;:}
        | floatt {:RESULT = VariablePrograma.FLOAT;:}
        | charr {:RESULT = VariablePrograma.CHAR;:}
;

VARGLOB ::= VARGLOB ASIG_VAR
        |
;

ASIG_VAR ::= TYPE:e1 LIST_ASIG:e2 puntocoma {:if(!sem.addListVar(e2, e1)){syntax_error(getS());}
                else {for(VariablePrograma var : e2){
                        var.setTipo(e1);
                        if(var.getTriplete() instanceof AsignarValor)
                        ((AsignarValor)var.getTriplete()).setTipo(Triplete.tipos[e1-1]);
                } RESULT = e2;}:}
        | TYPE:e1 id:e2 CORCHETES:e4 puntocoma {:
                if(!sem.addVar(new ArregloPrograma(e2, ProgramaSemantica.AMBITO, e1, e4, 
                new DefinirArreglo(null, new TerminalOperator(e2), Triplete.tipos[e1-1])))){
                        syntax_error(getS());
                }:}
;

CORCHETES ::= CORCHETES:e1 cora EXPR:e2 corc {:if(e2.getTipo()<=VariablePrograma.INT) e1.add(e2); RESULT = e1;:}
        | cora EXPR:e1 corc {:List<OperacionPrograma> opr = new ArrayList<>(); 
                if(e1.getTipo()<=VariablePrograma.INT) opr.add(e1);
                RESULT = opr;:}
;

LIST_ASIG ::= LIST_ASIG:e1 coma id:e2 ASIG:e3 {:
                if(e3!=null) e1.add(new VariablePrograma(e2, ProgramaSemantica.AMBITO, e3,
                new AsignarValor(null, new TerminalOperator(e2), e3.getTriplete())));
                else e1.add(new VariablePrograma(e2, ProgramaSemantica.AMBITO,
                new AsignarValor(null, new TerminalOperator(e2), null))); RESULT = e1;:}
            | id:e1 ASIG:e2 {:List<VariablePrograma> vars = new ArrayList<>();
            if(e2!=null) vars.add(new VariablePrograma(e1, ProgramaSemantica.AMBITO, e2,
                new AsignarValor(null, new TerminalOperator(e1), e2.getTriplete()))); 
            else vars.add(new VariablePrograma(e1, ProgramaSemantica.AMBITO,
                new AsignarValor(null, new TerminalOperator(e1), null))); RESULT = vars;:}
;

ASIG ::= igual EXPR:e1 {:RESULT = e1;:}
        |
;

OPERACION_A ::= OPERACION_A:e1 mas OPERACION_M:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new SumOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 menos OPERACION_M:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new RestOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 {:RESULT = e1;:}
;

OPERACION_M ::= OPERACION_M:e1 por OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new PorOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 div OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new DivOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_M:e1 mod OPERACION_U:e2 {:if(e1 != null && e2 != null) RESULT = new OperacionPrograma(e1, e2,
                new ModOperator(null, e1.getTriplete(), e2.getTriplete(), Triplete.devolverTipo(e1, e2)));:}
        | OPERACION_U:e1 {:RESULT = e1;:}
;

OPERACION_U ::= menos OPERACION_U:e1 {:if(e1 != null && e1.getTipo()==1){e1.setTipo(VariablePrograma.INT);}
                OperacionPrograma cero = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator("0"));
                RESULT = new OperacionPrograma(cero,
                e1, new RestOperator(null, cero.getTriplete(), e1.getTriplete(),
                Triplete.devolverTipo(cero, e1)));:}
        | mas OPERACION_U:e1 {:RESULT = e1;:}
        | ATOM:e1 {:RESULT = e1;:}
;

// Falta resolver lo de los corchetes
ATOM ::= id:e1 {:VariablePrograma var = sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)); 
                if(var == null){
                        syntax_error(getS());
                } else{RESULT = new OperacionPrograma(var.getTipo(), new TerminalOperator(e1));}:}
        | entero:e1 {:RESULT = new OperacionPrograma(VariablePrograma.INT, new TerminalOperator(e1));:}
        | decimal:e1 {:RESULT = new OperacionPrograma(VariablePrograma.FLOAT, new TerminalOperator(e1));:}
        | character:e1 {:RESULT = new OperacionPrograma(VariablePrograma.CHAR, new TerminalOperator(e1));:}
        | id:e1 CORCHETES:e2 {:VariablePrograma var = sem.existeVar(e1, e2.size());
                if(var == null){syntax_error(getS());}else{RESULT = new OperacionPrograma(var.getTipo(), new TerminalOperator(e1));}:}
        | para OPERACION_A:e1 parc {:RESULT = e1;:}
;

MAIN ::= voidd mainn para parc llavea STATEMENTS llavec
;

STATEMENTS ::= STATEMENT STATEMENTS
        | breakk puntocoma {:if(!esCase){syntax_error(getS());}:}
        |
;

STATEMENT ::= COMPOUND
        | STATEMENTLINE
;

COMPOUND ::= WHILE
        | DO_WHILE
        | FOR
        | IF_ELSE
        | SWITCH
;

STATEMENTLINE ::= clrs puntocoma
        | ASIG_VAR:e1 {:for(VariablePrograma var : e1){
                        var.mostrarTripletes();
                }:}
        | DEF_VAR puntocoma
        | PRINTF
        | SCANF
        | LLAMADA_METODO puntocoma
        | getch puntocoma
        | CLASS
;

DEF_VAR ::= id:e1 igual EXPR:e2 {:if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)) == null
                || e2 == null) {
                        syntax_error(getS());
                } else {AsignarValor asig = new AsignarValor(null, new TerminalOperator(e1), e2.getTriplete());
                        e2.mostrarTripletes(); System.out.println(asig.devolverString());}:}
        | id:e1 CORCHETES:e2 igual EXPR:e3 {:VariablePrograma var = sem.existeVar(e1, e2.size());
                if(var == null){syntax_error(getS());}else {OperacionPrograma arr = new ArregloPrograma(var.getId(), ProgramaSemantica.AMBITO,
                var.getTipo(), e2, (ArregloPrograma) var, e3); arr.mostrarTripletes(); }:}
;

PRINTF ::= printf para string VARS parc puntocoma
;

/*STRING ::= comilla STR comilla
;

STR ::= STR txt
        | STR MASCARA
        | txt
        | MASCARA
;

MASCARA ::= intpor
        | floatpor
        | charpor
;*/

VARS ::= VARS coma OPERACION_A
        |
;

SCANF ::= scanf para string VARSS parc puntocoma
;

VARSS ::= VARSS coma asig id
        |
;

IF_ELSE ::= iff para CONDICION parc llavea {:ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS llavec ELSE_IF ELSE {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
;

ELSE_IF ::= ELSE_IF elsee iff para CONDICION parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
        |
;

ELSE ::= elsee llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
        |
;

SWITCH ::= switchh para EXPR parc llavea CASES DEFAULT llavec
;

CASES ::= CASES CASE
        | 
;

CASE ::= casee OPERACION_A dosp {:esCase = true; ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS {:esCase = false; sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
;

DEFAULT ::= defaultt dosp {:esCase = true; ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS {:esCase = false; sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
        |
;

WHILE ::= whilee para CONDICION parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
;

DO_WHILE ::= doo llavea {:ProgramaSemantica.AMBITO += 1;:} 
        STATEMENTS llavec whilee para CONDICION parc {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
;

FOR ::= forr para INICIO puntocoma CONDICION puntocoma STEP parc llavea {:ProgramaSemantica.AMBITO += 1;:}
        STATEMENTS llavec {:sem.eliminarAmbito(ProgramaSemantica.AMBITO); ProgramaSemantica.AMBITO -= 1;:}
;

INICIO ::= DEF_VAR
        | id
        | TYPE DEF_VAR
;

STEP ::= DEF_VAR
        | OP_VAR
;

OP_VAR ::= id:e1 masmas {:if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)) == null){
                        syntax_error(getS());
                }:}
        | id:e1 menosmenos {:if(sem.existeVar(new VariablePrograma(e1, ProgramaSemantica.AMBITO, null)) == null){
                        syntax_error(getS());
                }:}
;

CONDICION ::= CONDICION orr AND
        | AND
;

AND ::= AND andd NOT
        | NOT
;

NOT ::= nott NOT
    | COMPARACION
;

COMPARACION ::= OPERACION_A:e1 igig OPERACION_A:e2 {::}
    | OPERACION_A:e1 noigual OPERACION_A:e2
    | OPERACION_A:e1 menor OPERACION_A:e2
    | OPERACION_A:e1 menorig OPERACION_A:e2
    | OPERACION_A:e1 mayor OPERACION_A:e2
    | OPERACION_A:e1 mayorig OPERACION_A:e2 {::}
    | para CONDICION:e1 parc {:RESULT = e1;:}
;

LLAMADA_METODO ::= pyy punto id:e1 para LIST_PARAM:e2 parc {:if(!sem.existeMetodoPY(e1, e2)){
                                syntax_error(getS());
                        }:}
                | vbb punto id:e1 para LIST_PARAM:e2 parc {:if(!sem.existeMetodoVB(e1.toLowerCase(), e2)){
                                syntax_error(getS());
                        }:}
                | javaa punto id:e1 punto id:e2 para LIST_PARAM:e3 parc {:if(!sem.existeMetodoJV(e1, e2, e3)){
                                syntax_error(getS());
                        }:}
;

EXPR ::= LLAMADA_METODO:e1 {::}
        | OPERACION_A:e1 {:RESULT = e1;:}
        | getch {:RESULT = new OperacionPrograma(VariablePrograma.INT, null);:}
;

CLASS ::= javaa punto id LIST_CLASS puntocoma        
;

LIST_CLASS ::= LIST_CLASS coma id PARAM
            | id PARAM
;

PARAM ::= para LIST_PARAM parc
        |
;

LIST_PARAM ::= LIST:e1 {:RESULT = e1;:}
        | {:RESULT = new ArrayList<>();:}
;

LIST ::= LIST_PARAM:e1 coma OPERACION_A:e2 {:e1.add(e2); RESULT = e1;:}
        | OPERACION_A:e1 {:List<OperacionPrograma> params = new ArrayList<>(); params.add(e1); RESULT = params;:}
;