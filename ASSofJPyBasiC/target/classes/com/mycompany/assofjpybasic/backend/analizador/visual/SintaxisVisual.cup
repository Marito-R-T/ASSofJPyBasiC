package com.mycompany.assofjpybasic.backend.analizador.visual;

import java_cup.runtime.*;
import com.mycompany.assofjpybasic.backend.semantica.visual.*;
import java.util.ArrayList;
import java.util.List;

class SintaxisVisual;

parser code
{:
    private Symbol s;
    private VisualSemantica sem = new VisualSemantica();
    private boolean error = false;
    private MetodoVisual actual;

    public void syntax_error(Symbol sym){
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception{
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public Symbol getS(){
        return this.cur_token;
    }
:};

terminal String espacio, subb, functionn, endd, publicc, dimm, ass, nott, andd;
terminal String orr, integerr, decimall, charr, iff, elseiff, elsee, thenn, selectt;
terminal String casee, forr, to, stepp, nextt, whilee, doo, loopp, igual, noigual, menor;
terminal String menorig, mayor, mayorig, mas, menos, por, div, mod, floor, para, parc, coma;
terminal String com, id, decimal, entero, character, y, string;
terminal String write, writeln, charinput, floatinput, intinput;
terminal String returnn;

non terminal VISUAL, STATESM, STATEM, SUB, FUNCTION, DEFVAR, ASIGVAR, ID;
non terminal STATEMENTS, STATEMENT, CASEELSE, ESP;
non terminal IF_ELSE, BLOQUEIF, ELSE_IF, THEN, STATEMENTLINE, SELECT, CASE, CASES, STEP, CA, PUBLIC;
non terminal LIST_CASE, FOR, WHILE, DO_WHILE, CONSOLEWRITE, INPUT, CONDICION, AND, NOT, COMPARACION, STRING;
non terminal STATEMENTSF;
non terminal List<VariableVisual> LISTPARAMM, LISTPARAM, LISTVAR;
non terminal String TYPE, TYPEE;
non terminal OperacionVisual EXPR, OPERACION_A, OPERACION_M, OPERACION_U, ATOM, D, DEF;

start with VISUAL;

VISUAL ::= ESP STATESM
;

ESP ::= espacio
    |
;

PUBLIC ::= publicc
        |
;

STATESM ::= STATEM STATESM
        |
;

STATEM ::= SUB
        | FUNCTION
;

SUB ::= PUBLIC subb id:e1 para LISTPARAMM:e2 parc espacio {:VisualSemantica.AMBITO += 1;
                                        MetodoVisual met = new MetodoVisual(e1, e2, VisualSemantica.VOID);
                                        actual = met;
                                        sem.addListVar(e2);
                                        if(!sem.addMetodo(met)){syntax_error(getS());}:}
                                        STATEMENTS endd subb espacio {:sem.eliminarAmbito(VisualSemantica.AMBITO);
                                        VisualSemantica.AMBITO -= 1;:}
;

FUNCTION ::= PUBLIC functionn id:e1 para LISTPARAMM:e2 parc TYPE:e3 espacio {:VisualSemantica.AMBITO += 1;
                                        MetodoVisual met = new MetodoVisual(e1, e2, e3);
                                        actual = met; met.setVisual(new VariableVisual(e1, VisualSemantica.AMBITO));
                                        e2.add(met.getVisual()); sem.addListVar(e2);
                                        if(!sem.addMetodo(met)){syntax_error(getS());}:} 
                                        STATEMENTSF endd functionn espacio {:sem.eliminarAmbito(VisualSemantica.AMBITO);
                                        VisualSemantica.AMBITO -= 1;:}
;

DEFVAR ::= dimm LISTVAR:e1 espacio {:if(VisualSemantica.tienenTipos(e1)&&sem.addListVar(e1)){}
                                        else{syntax_error(getS());}:}
;

LISTPARAMM ::= LISTPARAM:e1 {:RESULT = e1;:}
            | {:RESULT = new ArrayList<>();:}
;

LISTPARAM ::= LISTPARAM:e1 coma id:e2 TYPE:e3 {:e1.add(new VariableVisual(e2, (VisualSemantica.AMBITO + 1), e3));
                                        RESULT = e1;:}
        | id:e1 TYPE:e2 {:List<VariableVisual> var = new ArrayList<>();
                        var.add(new VariableVisual(e1, (VisualSemantica.AMBITO + 1), e2));
                        RESULT = var;:}
;

LISTVAR ::= LISTVAR:e1 coma id:e2 TYPEE:e3 DEF:e4 {:String tipo = VariableVisual.verificarTipo(e3, e4);
                        VariableVisual va = new VariableVisual(e2, VisualSemantica.AMBITO, tipo);
                        va.setDefinido(e4 != null); va.setAstipo(e3 != null && e4 == null);
                        if(tipo == null && e3 != null && e4 != null){
                                syntax_error(getS());
                        } else if(e3 != null && e4 == null){
                                e1.add(va);
                                VisualSemantica.cambiarT(e1, e3);
                        } RESULT = e1;:}
        | id:e1 TYPEE:e2 DEF:e3 {:List<VariableVisual> vars = new ArrayList<>(); String tipo = VariableVisual.verificarTipo(e2, e3);
                        VariableVisual va = new VariableVisual(e1, VisualSemantica.AMBITO, tipo);
                        va.setDefinido(e3 != null); va.setAstipo(e2 != null && e3 == null);
                        if(tipo == null && e2 != null && e3 != null){
                                syntax_error(getS());
                        } vars.add(va); RESULT = vars;:}
;

ASIGVAR ::= id:e1 igual EXPR:e2 espacio {:VariableVisual var = sem.existeVar(new VariableVisual(e1, VisualSemantica.AMBITO));
                                if(var==null || !var.getTipo().contains(e2.getTipo())){syntax_error(getS());}:}
;

TYPE ::= ass integerr {:RESULT = VisualSemantica.INT;:}
        | ass charr {:RESULT = VisualSemantica.CHAR;:}
        | ass decimall {:RESULT = VisualSemantica.FLOAT;:}
;

TYPEE ::= ass integerr {:RESULT = VisualSemantica.INT;:}
        | ass charr {:RESULT = VisualSemantica.CHAR;:}
        | ass decimall {:RESULT = VisualSemantica.FLOAT;:}
        | {:RESULT = null;:}
;

DEF ::= igual EXPR:e1 {:RESULT = e1;:}
        | {:RESULT = null;:}
;

OPERACION_A ::= OPERACION_A:e1 mas OPERACION_M:e2 {:if(e1!=null && e2 !=null){RESULT = new OperacionVisual(e1, e2);}:}
        | OPERACION_M:e1 menos OPERACION_M:e2 {:if(e1!=null && e2 !=null){RESULT = new OperacionVisual(e1, e2);}:}
        | OPERACION_M:e1 {:RESULT = e1;:}
;

OPERACION_M ::= OPERACION_M:e1 por OPERACION_U:e2 {:if(e1!=null && e2 !=null){RESULT = new OperacionVisual(e1, e2);}:}
        | OPERACION_M:e1 div OPERACION_U:e2 {:if(e1!=null && e2 !=null){RESULT = new OperacionVisual(e1, e2);}:}
        | OPERACION_M:e1 floor OPERACION_U:e2 {:if(e1!=null && e2 !=null){RESULT = new OperacionVisual(e1, e2);}:}
        | OPERACION_M:e1 mod OPERACION_U:e2 {:if(e1!=null && e2 !=null){RESULT = new OperacionVisual(e1, e2);}:}
        | OPERACION_U:e1 {:RESULT = e1;:}
;

OPERACION_U ::= menos OPERACION_U:e1 {:RESULT = e1;:}
        | mas OPERACION_U:e1 {:RESULT = e1;:}
        | ATOM:e1 {:RESULT = e1;:}
;

ATOM ::= id:e1 {:VariableVisual var = sem.existeVar(new VariableVisual(e1, VisualSemantica.AMBITO)); 
                if(var==null){syntax_error(getS());} else {
                RESULT = new OperacionVisual(var.getTipo());
                }:}
        | entero {:RESULT = new OperacionVisual(VisualSemantica.INT);:}
        | decimal {:RESULT = new OperacionVisual(VisualSemantica.FLOAT);:}
        | para OPERACION_A:e1 parc {:RESULT = e1;:}
;

STATEMENTS ::= STATEMENTS STATEMENT
        |
;

STATEMENTSF ::= STATEMENT STATEMENTSF
        | returnn EXPR:e1 {:if(e1 == null || !actual.getTIPO().contains(e1.getTipo())){syntax_error(getS());}:}
        |
;

EXPR ::= OPERACION_A:e1 {:RESULT = e1;:}
        | D:e1 {:RESULT = e1;:}
        | character {:RESULT = new OperacionVisual(VisualSemantica.CHAR);:}
;

STATEMENT ::= IF_ELSE
        | SELECT
        | FOR
        | WHILE
        | DO_WHILE
        | STATEMENTLINE
;

IF_ELSE ::= iff CONDICION BLOQUEIF
;

BLOQUEIF ::= thenn {:VisualSemantica.AMBITO += 1;:} STATEMENTLINE 
                espacio {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
        | THEN espacio {:VisualSemantica.AMBITO += 1;:} STATEMENTS ELSE_IF endd iff espacio 
                {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
;

ELSE_IF ::= elseiff CONDICION THEN espacio {:VisualSemantica.AMBITO += 1;:} STATEMENTS
                {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:} ELSE_IF
        | elsee espacio {:VisualSemantica.AMBITO += 1;:} STATEMENTS {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
        |
;

THEN ::= thenn
        |
;

STATEMENTLINE ::= CONSOLEWRITE
        | INPUT
        | DEFVAR
        | ASIGVAR
;

SELECT ::= selectt CA EXPR espacio CASES CASEELSE endd selectt espacio
;

CA ::= casee
        | 
;

CASEELSE ::= casee elsee espacio {:VisualSemantica.AMBITO += 1;:}
                STATEMENTS {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
        |
;

CASES ::= CASES CASE
        |
;

CASE ::= casee LIST_CASE espacio {:VisualSemantica.AMBITO += 1;:}
                 STATEMENTS {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
;

LIST_CASE ::= LIST_CASE coma OPERACION_A
        | OPERACION_A
;

FOR ::= forr id TYPE igual OPERACION_A to OPERACION_A STEP espacio {:VisualSemantica.AMBITO += 1;:}
                STATEMENTS nextt ID espacio {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
;

ID ::= id
    |
;

STEP ::= stepp OPERACION_A
        |
;

WHILE ::= whilee CONDICION espacio {:VisualSemantica.AMBITO += 1;:} STATEMENTS endd whilee espacio
;

DO_WHILE ::= doo whilee CONDICION espacio {:VisualSemantica.AMBITO += 1;:} 
                STATEMENTS loopp espacio {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
        | doo espacio {:VisualSemantica.AMBITO += 1;:} 
                STATEMENTS loopp whilee CONDICION espacio {:sem.eliminarAmbito(VisualSemantica.AMBITO); VisualSemantica.AMBITO -= 1;:}
;

CONSOLEWRITE ::= write para STRING parc espacio
        | writeln para STRING parc espacio
;

INPUT ::= D espacio
;

D ::= charinput para string parc {:RESULT = new OperacionVisual(VisualSemantica.CHAR);:}
        | floatinput para string parc {:RESULT = new OperacionVisual(VisualSemantica.FLOAT);:}
        | intinput para string parc {:RESULT = new OperacionVisual(VisualSemantica.INT);:}
;

CONDICION ::= CONDICION orr AND
        | AND
;

AND ::= AND andd NOT
        | NOT
;

NOT ::= nott NOT
    | COMPARACION
;

COMPARACION ::= OPERACION_A igual OPERACION_A
    | OPERACION_A noigual OPERACION_A
    | OPERACION_A menor OPERACION_A
    | OPERACION_A menorig OPERACION_A
    | OPERACION_A mayor OPERACION_A
    | OPERACION_A mayorig OPERACION_A
    | para CONDICION parc
;

STRING ::= STRING y EXPR
        | STRING y string
        | EXPR
        | string
;