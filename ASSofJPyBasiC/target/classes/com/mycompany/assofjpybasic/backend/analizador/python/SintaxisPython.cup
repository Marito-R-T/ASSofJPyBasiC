package com.mycompany.assofjpybasic.backend.analizador.python;

import java_cup.runtime.*;
import com.mycompany.assofjpybasic.backend.semantica.python.*;
import java.util.ArrayList;
import java.util.List;

class SintaxisPython;

parser code
{:
    private Symbol s;
    private PythonSemantica sem = new PythonSemantica();
    private MetodoPython actual;
    
    public void syntax_error(Symbol sym){
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public void unrecovered_syntax_error(Symbol sym) throws java.lang.Exception{
        System.out.println("\n" + sym.value + sym.sym);
        System.out.println("Error Sintactico en la letra: " + sym.value + "   <linea>: "  + (sym.right + 1) + "    <columna>: " + (sym.left + 1) + "\n");
    }

    public Symbol getS(){
        return this.cur_token;
    }
:};

terminal String deff, nott, andd, orr, iff, elseiff, elsee, forr, inn, range, whilee;
terminal String noigual, menor, menorig, mayor, mayorig, igig, mas, menos, por, div;
terminal String mod, floor, para, parc, coma, dosp, print, charinput, intinput, floatinput;
terminal String igual, puntocoma, returnn;
terminal String com, id, entero, decimal, character, string, indent, dedent, newline;

non terminal PYTHON, ESP, DEFS, SUITE, STMT_LIST, PC, STATEMENTLINE, AS_VAR;
non terminal WRITE, STATEMENTS, IF, ELSEIF, ELSE, WHILE, COMA, FOR, RANGE;
non terminal CONDICION, AND, NOT, STATEMENT, RETURN;
non terminal COMPARACION, STRING, DEF;
non terminal List<VariablePython> LISTVAR, PAR_LIST;
non terminal List<OperacionPython> LISTDEF;
non terminal OperacionPython INPUT, OPERACION_A, D, OPERACION_M, OPERACION_U, ATOM;

start with PYTHON;

PYTHON ::= ESP DEFS
        | ESP
;

ESP ::= newline
    |
;

DEFS ::= DEFS DEF
        | DEF 
;

DEF ::= deff id:e1 para PAR_LIST:e2 parc dosp {:MetodoPython met = new MetodoPython(e1, e2);
                                actual = met;
                                sem.addVar(e2);
                                if(!sem.addMetodo(met)){
                                        syntax_error(getS());
                                }:} SUITE {:if(actual.getTIPO() == null){
                                        actual.setTIPO(PythonSemantica.VOID);
                                }:}
        | deff id:e1 para parc dosp {:MetodoPython met = new MetodoPython(e1, new ArrayList<>());
                                actual = met;
                                if(!sem.addMetodo(met)){
                                        syntax_error(getS());
                                }:} SUITE {:if(actual.getTIPO() == null){
                                        actual.setTIPO(PythonSemantica.VOID);
                                }:}
;

PAR_LIST ::= PAR_LIST:e1 coma id:e2 {:e1.add(new VariablePython(e2, 1)); RESULT = e1;:}
        | id:e1 {:List<VariablePython> var = new ArrayList<>(); var.add(new VariablePython(e1, 1)); RESULT = var;:}
;

SUITE ::=  {:PythonSemantica.AMBITO += 1;:} STMT_LIST newline  {:sem.eliminarAmbito(PythonSemantica.AMBITO);
                                                PythonSemantica.AMBITO -= 1;:}
        |  {:PythonSemantica.AMBITO += 1;:} newline indent STATEMENTS dedent  {:sem.eliminarAmbito(PythonSemantica.AMBITO);
                                                PythonSemantica.AMBITO -= 1;:}
;

STMT_LIST ::= STATEMENTLINE puntocoma STMT_LIST
        | STATEMENTLINE PC
;

PC ::= puntocoma
        |
;

STATEMENTLINE ::= AS_VAR {::}
        | WRITE
        | INPUT
        | returnn D:e1 {:if(actual.getTIPO() == null || actual.getTIPO().equals(PythonSemantica.VAR)){
                actual.setTIPO(e1.getTipo());
        } else if(!actual.getTIPO().contains(e1.getTipo())){
                syntax_error(getS());
        }:}
;

AS_VAR ::= LISTVAR:e1 coma igual LISTDEF:e2 coma {:if(!sem.addVar(e1, e2)){syntax_error(getS());}:}
        | LISTVAR:e1 igual LISTDEF:e2 {:if(!sem.addVar(e1, e2)){syntax_error(getS());}:}
;

LISTVAR ::= LISTVAR:e1 coma id:e2 {:e1.add(new VariablePython(e2, PythonSemantica.AMBITO)); RESULT = e1;:}
        | id:e1 {:List<VariablePython> var = new ArrayList<>();
                var.add(new VariablePython(e1, PythonSemantica.AMBITO)); RESULT = var;:}
;

LISTDEF ::= LISTDEF:e1 coma D:e2 {:e1.add(e2); RESULT = e1;:}
        | D:e1 {:List<OperacionPython> op = new ArrayList<>(); op.add(e1); RESULT = op;:}
;

D ::= character {:RESULT = new OperacionPython(PythonSemantica.CHAR);:}
    | OPERACION_A:e1 {:RESULT = e1;:}
    | INPUT:e1 {:RESULT = e1;:}
;

WRITE ::= print para STRING parc
;

INPUT ::= intinput para string parc {:RESULT = new OperacionPython(PythonSemantica.INT);:}
        | charinput para string parc {:RESULT = new OperacionPython(PythonSemantica.CHAR);:}
        | floatinput para string parc {:RESULT = new OperacionPython(PythonSemantica.FLOAT);:}
;

STATEMENTS ::= STATEMENT STATEMENTS
        | STATEMENT
;

STATEMENT ::= IF
        | FOR
        | WHILE
        | STMT_LIST newline
;

IF ::= iff CONDICION dosp SUITE ELSEIF ELSE
;

ELSEIF ::= ELSEIF elseiff CONDICION dosp SUITE
        |
;

ELSE ::= elsee dosp SUITE
        |
;

WHILE ::= whilee CONDICION dosp SUITE
;

COMA ::= coma
        |
;

FOR ::= forr LISTVAR COMA inn RANGE dosp SUITE
;

RANGE ::= range para OPERACION_A parc
        | range para OPERACION_A coma OPERACION_A parc
        | range para OPERACION_A coma OPERACION_A coma OPERACION_A parc
;

OPERACION_A ::= OPERACION_A:e1 mas OPERACION_M:e2 {:RESULT = new OperacionPython(e1, e2);:}
        | OPERACION_M:e1 menos OPERACION_M:e2 {:RESULT = new OperacionPython(e1, e2);:}
        | OPERACION_M:e1 {:RESULT = e1;:}
;

OPERACION_M ::= OPERACION_M:e1 por OPERACION_U:e2 {:RESULT = new OperacionPython(e1, e2);:}
        | OPERACION_M:e1 div OPERACION_U:e2 {:RESULT = new OperacionPython(e1, e2);:}
        | OPERACION_M:e1 floor OPERACION_U:e2 {:RESULT = new OperacionPython(e1, e2);:}
        | OPERACION_M:e1 mod OPERACION_U:e2 {:RESULT = new OperacionPython(e1, e2);:}
        | OPERACION_U:e1 {:RESULT = e1;:}
;

OPERACION_U ::= menos OPERACION_U:e1 {:RESULT = e1;:}
        | mas OPERACION_U:e1 {:RESULT  = e1;:}
        | ATOM:e1 {:RESULT = e1;:}
;

ATOM ::= id:e1 {:VariablePython tipo = sem.existeVar(new VariablePython(e1, PythonSemantica.AMBITO));
                if(tipo==null){syntax_error(getS());} else {RESULT = new OperacionPython(tipo.getTipo());}:}
        | entero {:RESULT = new OperacionPython(PythonSemantica.INT);:}
        | decimal {:RESULT  = new OperacionPython(PythonSemantica.FLOAT);:}
        | para OPERACION_A:e1 parc {:RESULT = e1;:}
;

CONDICION ::= CONDICION orr AND
        | AND
;

AND ::= AND andd NOT
        | NOT
;

NOT ::= nott NOT
    | COMPARACION
;

COMPARACION ::= OPERACION_A igig OPERACION_A
    | OPERACION_A noigual OPERACION_A
    | OPERACION_A menor OPERACION_A
    | OPERACION_A menorig OPERACION_A
    | OPERACION_A mayor OPERACION_A
    | OPERACION_A mayorig OPERACION_A
    | para COMPARACION parc
;

STRING ::= STRING coma D
        | STRING coma string
        | D
        | string
;